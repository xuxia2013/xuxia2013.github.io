{"pages":[{"title":"","text":"联系我 Github: https://github.com/xuxia2013 博客地址：https://xuxia2013.github.io/ twitter: https://twitter.com/_nora_xu email: xuxia01@wondersgroup.com medium: https://medium.com/@_noraxu 豆瓣：https://www.douban.com/people/154085098/?_i=2434153F2-T280 微信公众号 作者 热爱技术，兴趣广泛，并长期参与开源。 后端，Python / Node 前端，React / Vue / 小程序 / flutter / webpack / babel 目前在万达信息入职，如果你正在找工作，点此处 学的都是计算机,热爱互联网 好奇心很重，喜欢徒步 容易知足，爱撸猫 野生设计师 不单纯开发工程师 目前正在深挖自己感兴趣的东西，寻求第二职业 阅读 软件 微信读书 豆瓣评分 播客 软件 喜马拉雅 得到app 小宇宙 Apple Podcasts 配件 Airpods pro 在得到还不为人知的时候，我已经是资深用户了，在此之前，podcasts陪伴我很多年。在上班，在等地铁，在排队，在一个人在家做菜的时候，带上蓝牙耳机，仿佛一切与我隔绝。感受特别棒现在用的比较多的是得到和小宇宙。 我听得比较多的是这些： 喜马拉雅 齐俊杰看财经 牛油果烤面包 小宇宙 黑水公园 三五环 奇想驿 by 产品沉思录 无人知晓 忽左忽右 声东击西 macTalk 或者直接扫描下方： 如果你有好的播客内容，也欢迎在评论区留言。","link":"/about/index.html"},{"title":"","text":"前端链接 Uniapp教程 NodeJs教程","link":"/all/index.html"},{"title":"","text":"收藏小站 收藏夹 https://panjiachen.github.io/awesome-bookmarks/repository/https://zhaomenghuan.js.org/nav/ Software-Engineering-at-Google https://qiangmzsx.github.io/Software-Engineering-at-Google/#/?id=software-engineering-at-google web安全 https://websec.readthedocs.io/zh/latest/ 我在github上学习前端 https://github.com/EbookFoundation/free-programming-books/blob/main/books/free-programming-books-zh.md#javascript https://github.com/getify/You-Dont-Know-JS https://github.com/royeo/awesome-programming-books#javascript https://github.com/zhuyingda/front-end-collect https://github.com/exacity/deeplearningbook-chinese 播客中文播客榜 https://xyzrank.com/#/hot-podcasts","link":"/link/index.html"}],"posts":[{"title":"Email 排版","text":"在做项目时，发现产品对推送的邮件内容这一部分要求很高，邮件内容要很丰富，同时支持多个邮箱客户端，web 端。大家都知道，邮件内容是否正常展示，字体等完全取决于邮件客户端，大多数邮件客户端会过滤 html 设置。让你的邮件看上去 low 到炸。 问题 如何编写 HTML Email，各个终端对 html 支持度，如何大概率正常展示邮件 node 如何起服务来发送邮件 如何做比较漂亮的邮件模板 MJML https://mjml.io/提供了新语法新标签来支持响应式页面布局，简单易上手，快速实现效果，把我们从 table 的泥沼中带出来了 但是笔者也发现很多问题：比如转发邮件，内容间距变得很宽很高，。想做宽度对齐的按钮，在桌面端偶尔出现上下布局的按钮 : ( 特点： 支持内联 123456&lt;mj-style inline=\"inline\"&gt; .blue-text div { color: blue !important; }&lt;/mj-style&gt; &lt;mj-attributes&gt; &lt;mj-class&gt; carousel, table, icon, image 等 mj-spacer 不建议使用，会出现多层空隙 支持原生 dom 1234567&lt;mj-raw&gt; &lt;!-- htmlmin:ignore --&gt;{% if foo &lt; 5 %}&lt;!-- htmlmin:ignore --&gt;&lt;/mj-raw&gt; &lt;!-- Some mjml section --&gt;&lt;mj-raw&gt; {% endif %}&lt;/mj-raw&gt; 官网: https://github.com/mjmlio/mjml demo: https://mjml.io/try-it-live/templates/basic （支持在线压缩） 教程：https://documentation.mjml.io/vscode 工具: https://marketplace.visualstudio.com/items?itemName=mjmlio.vscode-mjml（支持预览，出现特殊字符会报错，没有网页版try-it-live好用）还有桌面端应用。 NodeMailerNodemailer 是一个简单易用的 Node.js 邮件发送组件 支持抄送，附件 1234567891011121314151617181920212223import mjml2html from 'mjml'/* Compile an mjml string*/const htmlOutput = mjml2html(` &lt;mjml&gt; &lt;mj-body&gt; &lt;mj-section&gt; &lt;mj-column&gt; &lt;mj-text&gt; Hello World! &lt;/mj-text&gt; &lt;/mj-column&gt; &lt;/mj-section&gt; &lt;/mj-body&gt; &lt;/mjml&gt;`, options)/* Print the responsive HTML generated and MJML errors if any*/console.log(htmlOutput) 12345678910111213141516171819202122232425262728npm install nodemailer --saveconst transporter = nodemailer.createTransport({ service: email.service, secure: true, // true for 465, false for other ports auth: { user: email.user, // 发送邮箱 pass: email.pass, // smtp授权码 }, tls: { rejectUnauthorized: false, },}); await transporter.sendMail( { from: email.user, // sender address to, subject, // Subject line text, // plain text body html: // html模板 htmlOutput , }, (error, info) =&gt; { if (error) { return console.log(error, '------------error---send-------------'); } console.log('Message sent: %s', info.messageId); }); 参考：阮一峰 http://www.ruanyifeng.com/blog/2013/06/html_email.htmlhttps://www.caniemail.com/search/?s=table","link":"/7fc1b806681b/"},{"title":"Gitpod在线IDE","text":"如今，大家陆陆续续的都在家办公了，大家有没有发现，我们平时都是先安装好开发环境，下载 node,git,nvm 等，然后 git clone 项目，提交代码，大家各自严重依赖自己的本地开发环境。现在就有这一款这个工具，可以在浏览器上编辑推送代码，不用自己安装前端环境，随用随走。 在线办公，我相信这个是未来的趋势。 与传统的云和桌面 IDE 不同，Gitpod 能够理解环境并自动准备 IDE。 从官网介绍，Gitpod 是一个基于 Chorom Cloud 平台的在线 IDE，它可以快速的启动一个基于大多数流行语言的开发环境，并且可以很顺畅的进行开发。 如果你已经非常熟练使用 VS Code 进行开发的话，那么使用 Gitpod 将会无比的简单，因为从书写规范来说，这仅仅是 VS Code 的插件化扩展。 下面看一看如何使用 gitpod。 首先需要通过 OAuth 在 Github 授权 Gitpod 访问你的 Github 账号。 对于任何一个 Github 项目，只需要在前面添加： 1https://gitpod.io# 也可以安装插件 1https://chrome.google.com/webstore/detail/gitpod-always-ready-to-co/dodmmooeoklaejobgleioelladacbeki 就可以在 gitpod 中打开我的项目。 Gitpod 是一款开源产品，所以是完全可以在组织内部进行私有化部署服务的，这样就可以在私有代码仓库中使用上这款工具。 因为 Gitpod 是基于 VS Code、Docker 和 Kubernetes 等 OSS 技术，所以它熟悉、全面、可扩展且易于使用，但是也存在某些问题，基于浏览器，是不是内存和网络必然也是限制。大家可以说说你的看法。","link":"/6d12e01e8e04/"},{"title":"Turbopack 将会是 Web 下一代的打包工具","text":"10月26日，Vercel 推出并开源了下一代打包工具：Turbopack。由 Webpack 的创建者 Tobias Koppers 和 Next.js 团队使用 Rust 编写出来的。 尝试一下在 Next 中尝试 Turbopack 的 Alpha 版本：next dev –turbo。 Turbopack 对服务器组件、TypeScript、JSX、CSS 等提供了开箱即用的支持。不过在 Alpha 版期间，许多功能尚不受支持。 Next.js 中的 Turbopack 目前仅支持&nbsp;next dev，可查看支持的功能。开发团队还在努力通过 Turbopack 添加&nbsp;next build&nbsp;支持。未来我们将发布独立的 CLI、插件 API，并支持其他框架，如 Svelte 和 Vue。 Turbopack有多快 Turbopack 建立在新的增量体系结构上，以获得最快的开发体验。在大型应用中，它展示出了 10 倍于 Vite 的速度，700 倍于 Webpack 的速度。在更大的应用中，差异更加巨大 —— 通常比 Vite 快 20 倍。 Turbopack 在开发环境只打包需要的最小资产，所以启动飞快。在一个 3000 个模块的应用里，Turbopack 只花了 1.8 秒启动，Vite 花了 11.4 秒。 为什么 Turbopack 这么快Turbopack 的架构吸取了 Turborepo 和 Google 的 Bazel 等工具的经验教训，两个工具都专注于使用缓存，永远不会重复相同的工作。 Turbopack 是建立在 Turbo 之上的，Turbo 是基于 Rust 的开源、增量记忆化框架。Turbo 可以缓存程序中任何函数的结果。当程序再次运行时，函数将不会重新运行，除非它的参数改变了。这种粒度的架构使您的程序能够在函数级别跳过大量工作。 增量响应式系统，又有 Rust 的速度加持？Turbopack 是不可阻挡的！ Turbo 的未来首先，Turbopack 将用于 Next.js 的开发服务器。它将为闪电般快速的 HMR 提供动力，并天然支持 React Server Component，Typescript，JSX，CSS 等也一样。 Turbopack 最终也会赋能 Next.js 的生产环境构建，无论是本地还是云端。我们会在你的整个团队里共享 Turbo 的缓存，用Vercel Remote Caching[4]。 Webpack 用户还可以期望未来可以增量迁移到 Rust-based 的 Turbopack 特性。 我们对 Turbo 生态系统的未来感到更加兴奋，我们推动它来帮助你更快速的迭代，在灵感到来时更好的创造。 延伸阅读 https://turbo.build/pack/docs/core-conceptshttps://juejin.cn/post/7158997985870200839","link":"/7263a2032826/"},{"title":"UI自动化测试工具Puppeteer","text":"Puppeteer先献上 地址：https://github.com/puppeteer/puppeteer demo: https://try-puppeteer.appspot.com/ api: https://zhaoqize.github.io/puppeteer-api-zh_CN/ 概述通过 api 自动化控制 Chrome 如何使用要求：node &gt; v6.4.0 （如要使用 async / await，只有 Node v7.6.0 或更高版本才支持） 安装：yarn add puppeteer -S 能做什么官方回答 生成页面 PDF。 抓取 SPA（单页应用）并生成预渲染内容（即“SSR”（服务器端渲染））。 自动提交表单，进行 UI 测试，键盘输入等。 创建一个时时更新的自动化测试环境。使用最新的 JavaScript 和浏览器功能直接在最新版本的 Chrome 中执行测试。 捕获网站的 timeline trace，用来帮助分析性能问题。 测试浏览器扩展。 总结 爬虫，抓取任意网站的页面数据 ui 流程自动化测试 按业务逻辑来编写测试案例， 性能分析 通过生成 json 文件，拖到开发者工具中 performace 中查看 可以监听网站发出的请求，可以拦截，抓取响应的数据 可以设置代理服务器来访问网站 可以设置不同终端设备模拟器，通过截图来查看最终页面呈现效果 可以设置 delay sleep 来模拟真人输入和操作 可以监听 console, 接口抛出的异常，设置 cookie，键盘输入，鼠标移动 基于我们的 egg.js 可以做定时任务，定时检测；实现一套前端页面监控，便于自测 X 像 12306 登陆页面验证码过于复杂的网站，抓取数据有点困难，需要根据不同网站，个个攻破 √ api 友好，官方维护 代码示例：如何爬虫？ 1234567891011121314151617181920212223242526272829303132333435363738const puppeteer = require('puppeteer');1. 准备工作// windowconst browser = await puppeteer.launch({ headless: true, defaultViewport: { width: 1920, height: 1080, deviceScaleFactor: 1, },});// macconst browser = await puppeteer.launch({ headless: true, defaultViewport:null, executablePath: 'your chrome app path', // '/Applications/Google Chrome.app/'});const page = await browser.newPage();await browser.close();// 放在最后// 准备工作结束// 前往豆瓣网站，等待 dom 加载完成await page.goto('https://movie.douban.com/', { waitUntil: 'networkidle0' });await page.waitForSelector('.gaia-movie');// 爬虫开始const list = await page.evaluate(() =&gt; {const list = [...document.querySelectorAll(\".list-wp .slide-page[data-index='0'] a\")]; return list.map(el =&gt; { return { href: el.href.trim(), title: el.innerText.trim() }; });});consoele.log(list) ui流程： 模拟用户操作 123456789await page.goto('https://test-sat.meetsocial.cn/', { waitUntil: 'networkidle0' });// 前往某个网站await page.focus('#loginName'); // 模拟聚焦用户名输入框await page.type('#loginName', 'admin'); // 模拟用户名输入await page.type('#password', '********'); // 模拟密码输入await page.keyboard.press('Enter');// 模拟按键回车const cardBtn = await page.$('.ant-card'); // 跳转新的页面 进入/channelawait cardBtn.click(); // 点击事件await page.waitForSelector('#facebook section'); 使用trace性能分析（每个浏览器一次只能激活一个跟踪） 1234567891011121314151617await page.tracing.start({ path: './file/' + moment().format('YYYY-MM-DD-HH-mm-ssss') + '-trace.json',});await page.goto('https://test-sat.meetsocial.cn/', { waitUntil: 'networkidle0' });await page.tracing.stop(); 4. 拦截请求await page.setRequestInterception(true);page.on('request', interceptedRequest =&gt; {// console.log('interceptedRequest: ', interceptedRequest);// if (interceptedRequest.url().endsWith('.png') || interceptedRequest.url().endsWith('.jpg'))// interceptedRequest.abort();// else interceptedRequest.continue();});page.on('response', response =&gt; { console.log(response.url());}); 截图输出 1await page.screenshot({ path: './file/' + createTime + '.png', fullPage: true }); 模拟器 （手机 pad） 1await page.emulate(iPhone);","link":"/f0142a5f6230/"},{"title":"tabby：高颜值的终端工具","text":"今天给大家推荐一个开源的终端工具，非常漂亮，非常炫酷，当我们程序员在终端上敲命令行时，会有一种黑客的既视感，在我看来，有一个炫酷，漂亮的终端工具，更能彰显我们程序员的身份。 源码地址：https://github.com/Eugeny/tabby Tabby[1] 是一个基于 TypeScript 开发的终端模拟器，适用于 Windows，macOS 和 Linux。 功能也很强大，如下： 集成 SSH，Telnet 客户端和连接管理器 集成串行终端 定制主题和配色方案 完全可配置的快捷键和多键快捷键 拆分窗格 记住你的标签 支持 PowerShell（和 PS Core）、WSL、Git-Bash、Cygwin、MSYS2、Cmder 和 CMD 在 SSH 会话中通过 Zmodem 进行直接文件传输 完整的 Unicode 支持，包括双角字符 不会因快速的输出而卡住 Windows 上的正确 shell 体验，包括 tab 自动补全（通过 Clink） Integrated encrypted container for SSH secrets and configuration SSH、SFTP 和 Telnet 客户端可用作 Web 应用程序（也可托管） 不过，该项目目前处于 Alpha 阶段，我自己使用时也发现一些问题：比如暂时还不支持设置中文，插件数量还不够丰富等等。但总的来说，Tabby 仍是一个值得关注的项目，有需要的同学可以先尝试下。","link":"/3a18d28ae706/"},{"title":"30岁的人生总结","text":"从2014年7月份还没毕业就开始了第一个工作试用期的，找到了人生第一份工作薪资6000多，没什么机遇，纯粹是想快点找到一份工作，早点离开学校，在上海这个拥挤有活力的城市找到一份工作，很快就在上海租了一个不大的房子，有个超大的阳台和厨房，和两盆花草，一只小乌龟。在每天挤三次地铁的漕河泾上班。 试用期不到二个月的时候，就加入了公司的项目，刚开始因为有个”大神”庇佑，很快就入门了。Angular + bootstrap + gulp + git + sass 也是在慢慢研究中学习起来的。在很早的时候，就知道聪明的提问题，会比一般人学习要快很多，尤其是在前辈领导下，正确的提问题，会得到更好的答案。 再后来，做项目的时候，经常加班到晚上10点才回去，刚刚开始学东西的时候 还是很开心的，加班啥的不在乎，时间久了，吃不下饭，每天靠咖啡提神，晚上还是很兴奋睡不着；后来，又开始被经理折磨，不停的改需求的时候，开始懊恼为什么选这个专业·~ 慢慢的看到做的东西测试，上线，成就感，幸福感油然而生。 后来，去过创业公司，去过上市公司，很多学习资源来自网上，github、b站、油管或者某个国外/内的学习教程。都是白嫖来的知识。 也是去年，遇见了一个迷一样的男人，迅速闪婚，目前定居浙江。在一家上市公司做起了中层的技术管理工作，很多人问我，上海和浙江生活有什么区别，其实很多的： 生活，从996的内卷的工作氛围到拥有自己的生活，每天按时6点下班，周六日可以开车出门约会，赏花看音乐剧舞台剧，年轻的时候，不知道大家有没有写过很多人生清单，希望自己此生完成的一些梦想啥的，这些都是需要时间去做的，以前工作忙经常没有其他时间，然而现在都被我慢慢捡起来。 工作环境有很大不同，上海同事综合能力会更强，沟通和协作能力比较有优势。你的专业能力在上海比较吃香，在小公司就会比较看重你多个能力，哪里需要救火，哪里缺人，你就得补上去。 工资，上海薪资待遇更好，年假也更多，工作机会也更多，人生的可能性也更多。 每一种境遇带来不同的人生体验，生活和爱一直陪伴我们。","link":"/db2378ec1637/"},{"title":"uniapp大项目如何瘦身","text":"前一段时间，接到一个任务，uniapp移动端的应用要在微信小程序上线，看看我们在商店上架的apk应用包30M，这个项目是基于uniapp, uview-ui v1.8.4搭建的。要知道，微信小程序的要求很多的，后来，一周后，项目顺利上线，那我是怎么做的呢？ 微信官方要求 整个小程序所有分包大小不超过 20M 单个分包/主包大小不能超过 2M 用户隐私协议提交 —— 使用了获取用户信息的需要提交，比如获取定位，获取摄像头等 添加配置 pages.json 1234567891011121314151617181920\"mp-weixin\" : { \"appid\" : \"wx01a0a0b420ef4c14\", \"setting\" : { \"urlCheck\" : false, \"es6\" : true, \"minified\" : true // 重要 }, \"optimization\" : { \"subPackages\" : true // 重要 }, \"usingComponents\" : true, // 重要 \"uniStatistics\" : { \"enable\" : false }, \"permission\" : { \"scope.userLocation\" : { \"desc\" : \"您的位置将用于绑定您的区域\" } } } package.json 打包命令后添加 –minimize推荐使用 yarn dev:mp-weixin 开发者工具配置 分包处理其实就是把pages里对应的文件夹，拆分到同级文件夹去 https://uniapp.dcloud.io/collocation/pages.html#subpackages 引入包 统一使用@，因为有分包的页面，路径已经变了 12import api from \"@/api/index.js\";import { getDictionary } from \"@/common/util.js\"; 删掉项目多余插件，资源，不使用体积大的插件 比如axios，使用自带的uni.request 去掉 vue-signature-pad 素材压缩 方法1：使用图片压缩工具https://tinify.cn/，压缩图片 方法2：可以放到线上的图片尽量放在线上，使用cdn或者放在固定服务器上，最好和域名服务器同域名 开发中注意事项使用单位rpx 12345678text { width: 60rpx; height: 34rpx; line-height: 34rpx; font-size: 20rpx; border-radius: 6rpx; margin-left: 30rpx;} 使用弹性布局 推荐阅读文章：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html demo: https://codepen.io/enxaneta/pen/adLPwv 减少使用、不使用内联样式，推荐使用class来写减少使用uview的u-row, u-col， 推荐使用弹性布局，代码少，嵌套少navbar 怎么写 首选方案：在使用page.json配置 次方案：自定义，但不要自定义高度和字体大小，会不协调 降低代码量 uview-ui库能满足需求的尽量多使用，不要自己重新写css 页面组件能复用就复用，页面也是如此 新建/编辑/详情应该是同一套代码。页面元素一样的话，一个页面来写的话，后续补充也是比较轻便 页面跳转 encodeURIComponent url比较长有空格有特殊字符可以使用 decodeURIComponent 不写会在小程序中报错，h5、Android不报错 1234567891011 // 跳转页面 uni.navigateTo({ url: \"/nursing/orderDetail?kh05=\" + encodeURIComponent(JSON.stringify(e)) }); // 跳转后页面接收参数onLoad: function (option) { //option为object类型，会序列化上个页面传递的参数 this.kh05 = JSON.parse(decodeURIComponent(option.kh05)); //打印出上个页面传递的参数。 }, 小程序开发者工具会编译报错 一片红的时候，不要慌，检查下你的page.json不能出现多余的逗号和注释","link":"/778b2c51e967/"},{"title":"如何在uniapp快速实现一对一音视频通话应用","text":"需求：用户 A 和用户 B，通过摄像头，可以实现一对一、多对多的音视频互动直播。 其原理是进入同一个频道即可发布自己的音视频流并自动订阅其他用户的音视频流，进而实现音视频通话。我们采用 uniapp+第三方 anyRTC 集成。并且 anyRTC 提供每月免费赠送 1 万分钟实时音频、anyRTC 提供 rtm 服务。 如何集成 官网注册https://www.anyrtc.io/ 创建 anyRTC 账号 登录控制台，创建项目获取 appId 下载最新的 uniapp 开发软件：HBuilderX 前往插件市场下载：anyRTC音视频SDK插件 配置：打开 manifest.json 文件，选择 App 原生插件配置 =&gt; 远端插件 作自定义调试基座（采用云端插件或者本地） 真机模拟，开发 demo 展示 后台数据统计","link":"/0ec78993e7cf/"},{"title":"uniapp如何实现消息推送","text":"推送消息是app应用中非常重要的一个功能，尤其对于营销推广而言，没有什么途径比消息推送更能直接、即时地触及到目标用户群体。 推送消息的主要作用为： 1.活跃用户：促进用户活跃，提高用户粘性，带动app内模块的使用，新功能的尝试，留住用户2.用户召回：将合适的内容通过合适的渠道在合适的时间推送给合适的用户用户召回，提高留存，每天推送精准的信息（不多于2条为佳），而不是轰炸用户，达到最终效果=推送人群 * 推送成功率* 触达率 * 点击率 * 用户与内容匹配度。3.信息分发：信息告知和提醒，平台关于功能更新/内容更新/活动消息的发布可以来推送 如果你的公司也是用uniapp，那就继续看下去吧。 如果时间不够，用unipush，官方支持，免费使用，也是集成比较专业的个推公司服务我们采用的是极光，覆盖的平台多。需要自己看些文档来开发了，提供代码demo上手也容易的unipush和极光都支持，需要app在线推送，消息推送后，app离线的话，会保留一段时间，等待用户登录再行通知。 如果项目需要离线通知就比较麻烦了，为什么？ 由于手机厂商众多，他们各自都有不同的推送服务，包括Apple、google（仅能在海外使用）、华为、小米、oppo、vivo、魅族，以及还有一些没有专业推送服务的中小手机品牌。他们对App后台耗电都有查杀机制，除了微信等大应用，普通应用很难常驻后台。——来自uniapp文档 需要集成各个厂商通道的 SDK，部分厂商还要求必须上架应用市场才可以正常使用推送服务。详细如下： 你要收集七颗龙珠才可以召唤神龙，听听就很麻烦，这个也不是不能做，下一期我们单独说。 unipush推送 unipush介绍文档 UniPush开通指南 UniPush使用指南 极光推送极光注册 极光官网注册 登录极光后台 - 应用管理 - 创建极光应用 获得Appkey 免费插件 极光JCore官方SDK 极光JPush官方SDK 选择【购买for云打包】 项目配置 包名获取 点击发行-云打包查看 在hbuildx项目中配置 推送消息可以在极光平台上定制、配置推送=&gt;推送管理=&gt;创建推送=&gt;填表 uniapp 应用中加入代码在应用启动的时候，需要初始化以及监听极光消息推送 app.vue 1234567891011121314151617181920212223242526var jpushModule = uni.requireNativePlugin(\"JG-JPush\");jyJPush.android_init(res =&gt; { //初始化成功成功之后再设置别名 //官网的话：init后直接set操作有极大可能导致失败，可能会在回调里拿到6022,6002等，测试的时候可以做个7、8秒的延时，正式业务里一般配合用户注册使用，延时基本上够用 //实际上：我设置成10s才管用 setTimeout(() =&gt; { console.log('setAlias'); this.setAlias() }, 1000 * 10) //20秒后再设置别名 uni.showToast({ icon: 'none', title: JSON.stringify(res) })})//设置别名jyJPush.setJYJPushAlias({ userAlias: 'chxxtAlias'},result =&gt; { console.log('setJYJPushAlias', JSON.stringify(result)); uni.showToast({ icon: 'none', title: JSON.stringify(result) })}); 测试推送消息首先需要运行到手机上进行测试，这里使用真机进行测试，需要先制作一个自定义基座。 在 HbuilderX 点击 运行-运行到手机或模拟器-制作自定义调试基座，确认弹出窗口的信息后，点击打包。 等待打包结束后，在 HbuilderX 顶部点击运行-运行到手机或模拟器-运行基座选择，选择自定义调试基座。然后再点击运行到 Android App 基座，选择你的设备进行运行。 其他阅读 厂商通道参数申请指南 厂商推送应用创建配置流程 unipush 极光官网demo","link":"/e7307e5a7a5e/"},{"title":"vscode浅色主题使用","text":"一款看起来舒适的主题太重要了，加上高亮的效果，开发起来格外顺心顺意。身边很多程序员都热爱暗黑色系，但我却喜欢浅色系，自己也定义了很多主题。希望大家能找到自己喜欢的主题。 如何设置主题File -&gt; Preferences -&gt; Color Theme vscode自带主题light + Light High Contrast Quiet Light 安装新插件我是不喜欢自带的主题，无功无过。 经过不断试用，我找到了这一款: 简单，色彩鲜艳，共有6个选择，我选了【Ayu Mirage Bordered】赏心悦目。 https://marketplace.visualstudio.com/items?itemName=teabyii.ayu 效果如下： 自定义主题方式一默认的颜色主题配置文件都位于 Microsoft VS Code\\resources\\app\\extensions\\theme-defaults\\themes 目录中, 12345resources/app/extensions/ \\_ theme-my/ \\_ themes/ | \\_ color-theme.json |_ package.json 你完全可以安照这个结构自己复刻一个新的主题 123456789101112131415{ \"name\": \"theme-my-gray\", \"version\": \"0.1.0\", \"publisher\": \"my\", \"engines\": { \"vscode\": \"*\" }, \"contributes\": { \"themes\": [ { \"label\": \"my-gray\", \"uiTheme\": \"my\", \"path\": \"./themes/my-gray-color-theme.json\" } ] }} 方式二File -&gt; Preferences -&gt; Setting，以源码形式打开后，在再写些代码来配置 123456789101112\"workbench.colorCustomizations\": { \"editor.selectionBackground\": \"#409EFF\", // 编辑器所选内容的颜色 \"editor.findMatchBackground\": \"#F56C6C\", // 当前搜索匹配项的颜色 \"editor.findMatchHighlightBackground\": \"#e09a30\", // 其他搜索匹配项的颜色 \"menu.selectionBackground\": \"#409EFF\", \"list.hoverBackground\": \"#409EFF\", // 选中行背景色 \"editor.selectionHighlight\": true, \"list.inactiveSelectionBackground\": \"#ecf5ff\", // 左侧打开文件背景色 },\"editor.tokenColorCustomizations\": { \"comments\": \"#409EFF\", // 修改注释颜色}, 官网配置项文档：https://code.visualstudio.com/api/extension-guides/color-theme 方式三首先需要安装插件，用来生成主题。 1npm install -g yo generator-code 安装完毕之后，使用下面的命令来生成扩展的基本结构： 1yo code 运行上面的命令，需要你输入或者选择一些内容： 是否发送反馈 创建扩展类型，这里选择颜色主题 是创建新的还是导入现有的 主题是浅色还是深色、名称、创建者、其他用户在市场中看到的主题名等等 是否初始化git仓库 根据提示和自己的需要，直到提示创建成功, 再把文件themes放在方式一目录下 结束","link":"/1a222761d40a/"},{"title":"vue cli3整合多应用项目","text":"背景前一段时间接到领导指示去协助别的组一个项目，项目很是复杂，丢过来源码压缩包就有144M，项目中包含纯h5项目, 小型vue项目，这些页面互相之间没有什么关联，有一个首页链接到每一个小应用中，同时，有很多共同的依赖包，需求是能整合到一个项目中方便后续开发。考虑到业务代码太庞大，我自己对业务代码不太熟悉，万一调整太多遭到半路堵截，思虑再三，不过好在cli3版本增加了pages属性，配置起来相当轻松。 开始第一步首先 vue create app 初始化名为 app 的项目 第二步把目录结构调整成 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950├── public/ # 放置纯静态项目│ └── ...├── src/ # 项目代码入口│ ││ ├── components # 多个项目共享的组件│ ├── utils # 多个项目共享的工具库│ ├── assets # 多个项目共享的静态资源│ ││ └── pages # 多个项目页面划分│ ├── index/ # 首页项目│ │ ├── views # 页面│ │ ├── router.js # 路由文件│ │ ├── index.js # 页面/应用入口文件│ │ ├── app.vue│ │ ├── index.html│ │ └── ...│ ├── page1/ # 模块小应用│ │ ├── assets │ │ ├── components # 该页面/应用自身的组件│ │ ├── store # │ │ ├── router # 路由文件│ │ ├── utils # 该页面/应用自身的工具库│ │ ├── index.js # 页面/应用入口文件│ │ ├── app.vue│ │ ├── index.html│ │ └── ...│ └── page2/ # 第二个页面或者应用│ │ ├── index.js # 页面/应用入口文件│ │ └── ...│ └── pageN/ # 第N个页面或者应用│ ├── index.js # 页面/应用入口文件│ └── ...├── build/ # 项目打包代码│ ├── .../ # public静态项目│ ├── page1/ # 第一个页面或者应用│ │ ├── [hash].js│ │ └── index.html # 页面/应用入口文件│ ├── page2/ # 第二个页面或者应用│ │ ├── [hash].js│ │ └── index.html # 页面/应用入口文件│ └── pageN/ # 第N个页面或者应用│ ├── [hash].js│ └── index.html # 页面/应用入口文件├── babel.config.js # babel编译参数├── postcss.config.js├── vue.config.js├── .browserslistrc├── .eslintrc.js├── .gitignore└── package.json # 项目文件，记载着一些命令和依赖还有简要的项目描述信息, 还有共同的依赖包 文件解析package.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647{ \"name\": \"app\", \"version\": \"0.1.0\", \"private\": true, \"scripts\": { \"dev\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\", \"lint\": \"vue-cli-service lint\" }, \"dependencies\": { \"vue\": \"^2.6.10\", \"vuex\": \"^3.0.1\", \"vue-router\": \"^3.0.3\", \"vux\": \"^2.9.2\", \"axios\": \"^0.24.0\", \"reqwest\": \"^2.0.5\", \"vant\": \"^2.12.33\", \"mint-ui\": \"^2.2.13\", \"dragula\": \"^3.7.2\", \"fastclick\": \"^1.0.6\", \"fundebug-javascript\": \"^1.6.0\", \"fundebug-vue\": \"0.0.1\", \"amfe-flexible\": \"^2.2.1\", \"core-js\": \"^2.6.5\" }, \"devDependencies\": { \"@vue/cli-plugin-babel\": \"^3.5.0\", \"@vue/cli-plugin-eslint\": \"^3.5.0\", \"@vue/cli-service\": \"^3.5.0\", \"@vue/eslint-config-prettier\": \"^5.0.0\", \"autoprefixer\": \"^9.7.2\", \"babel-eslint\": \"^10.0.1\", \"babel-plugin-import\": \"^1.13.5\", \"eslint\": \"^5.16.0\", \"eslint-plugin-prettier\": \"^3.1.0\", \"eslint-plugin-vue\": \"^5.0.0\", \"glob\": \"^7.1.4\", \"less\": \"^3.0.4\", \"less-loader\": \"^4.1.0\", \"node-sass\": \"^4.13.0\", \"postcss-pxtorem\": \"^4.0.1\", \"prettier\": \"^1.18.2\", \"sass-loader\": \"^8.0.0\", \"vue-template-compiler\": \"^2.5.21\", \"@vux/loader\": \"^2.0.0-rc4\" }} vue.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const glob = require(\"glob\");// const autoprefixer = require(\"autoprefixer\");// const pxtorem = require(\"postcss-pxtorem\");const path = require(\"path\");// const vuxLoader = require(\"vux-loader\");function getEntry(url) { let entrys = {}; glob.sync(url).forEach(item =&gt; { // splice(-3)取数组后三项 let urlArr = item.split(\"/\").splice(-3); entrys[urlArr[1]] = { entry: \"src/pages/\" + urlArr[1] + \"/\" + \"index.js\", template: \"src/pages/\" + urlArr[1] + \"/\" + \"index.html\", filename: urlArr[1] + \".html\", title: \"pages-\" + urlArr[1] }; }); return entrys;}let pages = getEntry(\"./src/pages/**?/*.html\");module.exports = { lintOnSave: false, pages, devServer: { proxy: { \"/\": { target: \"\" } } }, css: { loaderOptions: { less: { lessOptions: { modifyVars: { \"text-color\": \"#111\", \"border-color\": \"#eee\", hack: `true; @import \"${path.join( __dirname, \"/src/pages/search/style/reset.less\" )}\";` } } } // postcss: { // plugins: [ // // autoprefixer(), // pxtorem({ // // rootValue: 37.5, //设置根元素为37.5px // propList: [\"*\"] // }) // ] // } } }, configureWebpack: config =&gt; { require(\"@vux/loader\").merge(config, { plugins: [\"vux-ui\"] }); }}; babel.config.js 1234567891011121314module.exports = { presets: [\"@vue/app\"], plugins: [ [ \"import\", { libraryName: \"vant\", libraryDirectory: \"es\", style: name =&gt; `${name}/style/less` }, \"vant\" ] ]}; 运行和构建 安装：yarn 运行: yarn dev，网页输入 http:localhost:8080 打包: yarn build 重新启动项目，访问下面两个地址即可看到多页面的效果。 http://localhost:8080/project1#/ http://localhost:8080/project2#/ 结束延伸阅读 https://cli.vuejs.org/zh/config/#pages","link":"/9eb64e997ad7/"},{"title":"优势谈判","text":"作者：罗杰•道森 (Roger Dawson) 豆瓣地址 读后感这是一本值得反复去读的书，第一次读就会发觉书里所说的道理在很多场合都适用，比如蚕食政策、服务贬值、避免敌对情绪，”谈判高手让买主觉得他赢了,拙劣的谈判手让买家觉得他输了“这些真是第一次听说，真是受用。 虔敬力价值观念坚定的人都有这种力量强调一个原则：你可以相信我，因为我有一套价值观，我不会背离这些价值观。 个人魅力专业力量 谈判高手尤其要注意下面四种重要的力量。四种力量结合其作用是巨大的。当这四种力量集合在一个人身上的时候，结果是让人难以置信的 1.合法权力：头衔的力量。 2.报偿力：报偿别人的力量。 3.虔敬力：坚定的价值观。 4.个人魅力：人格，表现出来的精神气质。 谈判高手知道如何让人们改变他们的立场，使他们能集中考虑共同的利益问题。要达到这个目的，就要熟悉你买主的不同个性，了解他们处理问题的不同方法。尽管他们的立场可能与你完全不同，要努力改变他们的立场，让他们把关注的焦点放在双方的共同利益之上。 谈判双赢的第二个关键是：不要认为他们想要的就是你想要的。如果你这么猜想，那么你就会认为你在谈判中所做的对他们有利的事情，就是对你有害的事情","link":"/56a3054d9167/"},{"title":"动物农场","text":"作者：乔治•奥威尔[英] 豆瓣地址 这是一本很有意思的书。全书都是在地铁里，医院等位的时候看完的，很短的一本书，却是我今年最迫不及待看完的小说，读的时候心情澎湃，读完意犹未尽。读完的时候，简直不肯相信已经结束了，不停的翻看全书，是不是遗漏的什么~~ hhh 书中，动物们齐心合力赶走了琼斯，梦想创建一个和谐美好的没有压迫的社会，可是事情渐渐的变化了。大败琼斯，小狗的出现，手拳击手的死去，风车的成功，拿破仑的领导，心情也随着起起伏伏。最爱书中最末一句： 外面的众生灵从猪看到人，又从人看到猪，再从猪看到人；但他们已分不出谁是猪，谁是人了。 讽刺之极。如同我们。悲惨如此。","link":"/a5467de46cfc/"},{"title":"史上最佳工具之Git客户端Fork","text":"Fork绝对是目前功能和交互最优秀的全功能的Git客户端，不仅有免费版，颜值超高，还具备非常多实用的功能，整体易用性已经达到很高的程度，下面就列举一些。 克隆项目在github上的项目clone一份到自己电脑上 查看克隆进度 查看项目中issues和Pull requests 去提一个issues 暂存工作区 添加 查看 文件树-查看Commit下所在分支的项目的全部文件 查看某个文件所有的变更历史右击-history 自带快速便捷的工具处理代码冲突 Cherry-pick单独挑出Commit，去提交到别的业务线 查看变更 进行差异展示 搜索提交记录 集中管理多个git账户 切换主题-暗黑模式 项目提交和贡献者的统计","link":"/cf63269fcdc6/"},{"title":"前端工程化-自动化运维部署之jenkins","text":"大部分公司的前端项目发布工作，都是通过jenkins ⭐20k和k8s ⭐94k来自动化的方式进行部署。正式环境都是运维部门去做的，申请上线单提前给过去，测试环境的话太频繁，几乎是开发或者测试来部署。目前我也只用过这两个工具，通过 web 操作，很是方便。 前端开发者平日里只需要把代码提交到 git 库即可，也无需懂这些活儿，面试的时候也很少涉及，你问，那为啥还要看这些？ 我不会说多学点东西是好的，因为再好的知识，对你没有用终归随着时间而淡忘。比如说在正式环境抛错，图片文件加载慢，测试环境正常，影响到用户使用的时候，你知道运维同学哪里没有配置好，nginx 没有配置好，gzip 没有开启，或者代码不是最新的时候，你能最快定位问题而不是去怀疑自己提交了有 bug 的代码。在你需要运维/后端同学配合优化项目的时候，你有资格和他们讨论怎么做，如何不给其他部门同事增加额外工作量，不使别人反感，同时快速推进功能，提升业务质量的时候。你会明白涉及到工作交付上下游同事的工作，你都应该多懂点。 今天就先聊聊 Jenkins 核心点持续集成随着业务增大，开发人员增多，项目迭代快速，多分支提交功能到测试分支，由测试分支合并到 uat 分支，再回归测试、压力测试后，再合并代码至 master 分支，完成业务迭代，与此同时，小优化小 bug 已经在开发分支提交测试了，多条任务线穿插…是不是已经应接不暇了。 持续集成就是可以快速迭代，在代码更新后，自动化测试（很多公司并不配置，业务来驱动），自动拉取，自动构建，自动部署到生产机子上，这一流程使项目质量得到很大的保证。同时这样每次更新一个功能点，发现错误也更容易、迅速。回滚代码操作也是非常简单。 持续交付就是说代码不管什么时候更新，用户总是无感的，随时可以交付产品/项目 持续部署代码经部们负责人代码审核后（或者没有这一环节），可以开始部署到生产阶段了。 环境 windows 安装包 Java 8 ( JRE 或者 JDK 都可以，支持 Java11-17 版本，链接) 下载 官网镜像地址: https://mirrors.jenkins.io/下载地址： https://jenkins.io/download/华为镜像地址: https://mirrors.huaweicloud.com/home阿里云：https://mirrors.aliyun.com/jenkins/?spm=a2c6h.13651104.0.0.c800db0exjUxTr 安装 官网：https://www.jenkins.io/zh/doc/pipeline/tour/getting-started/ 第一步 12λ cd /d D:\\software\\jenkins // 你的文件安装路径下λ java -jar jenkins.war --httpPort=7777 --enable-future-java // 端口号7777，默认8080 浏览器打开 http://localhost:7777/ 安装提示完成初始化 成功 全局配置至 Manage Jenkins -&gt; Global Tool Configuration, 配置 NodeJs 创建Pipeline 回滚配置 1234567891011121314151617181920212223242526272829echo \"##################################\"echo $WORKSPACEecho $BUILD_DISPLAY_NAMEecho \"Status:$Status\"case $Status in Deploy) #发布 path=\"${WORKSPACE}/bak/${BUILD_DISPLAY_NAME}\" #创建每次要备份的目录 if [ -d $path ]; then echo \"The files is already exists \" else mkdir -p $path fi \\cp -R ${WORKSPACE}/dist/. $path #将打包好的包备份到相应目录,覆盖已存在的目标 echo \"Completing!\" ;; Rollback) #回滚 cd ${WORKSPACE}/dist/ #进入备份目录 rm -rf * \\cp -rf ${WORKSPACE}/bak/$Version/. ${WORKSPACE}/dist/. #将备份拷贝到程序打包目录中，并覆盖之前的war包 echo \"Completing!\" ;; *) exit ;;esac 然后出现这样，就成功了. 每一次构建成功后，留下备份dist文件夹，复制一份到文件夹bak下，回滚的时候按手动选择哪次构建版本号来替换源文件 结束","link":"/9f5a64e98515/"},{"title":"大数据渲染解决方案一 — react-virtualized","text":"前端怎么处理大数据渲染 awak, DOM结构如果过大, 网页就会出现用户操作体验上的问题, 比如滚动, 点击等常用操作. 同时, 对react的虚拟DOM计算以及虚拟DOM反映到真实DOM的压力也会很大. 当用户点击切换按钮时, 就会出现秒级的卡顿. 解决问题核心：只加载可见区域的组件 react-virtualized是一个以高效渲染大型列表和表格数据的响应式组件 推荐：https://github.com/bvaughn/react-virtualized react-virtualized的基础组件有： Grid （推荐） List Table Masonry Collection 除此之外，还有些高阶组件。这里grid组件比较适合做网格的，做表格也是可以的，灵活度很高。list可以做排版类的长文列表。搭配 AutoSizer, InfiniteLoader, CellMeasurer, CellMeasurerCache做样式自适应，无限滚动。 比如下拉框中无限滚动加载： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import VirtualList from 'virtual-list';&lt;Select value={value} autoFocus open={open} onBlur={() =&gt; setOpen(false)} onMouseEnter={() =&gt; setOpen(true)} style={{minWidth: 200}} dropdownRender={() =&gt; ( &lt;div onMouseDown={(e) =&gt; e.preventDefault()}&gt; &lt;div style={{minHeight: 200}}&gt; &lt;VirtualList {...val} /&gt;{' '} &lt;/div&gt; &lt;small&gt; 总数：{total} 已加载：{data.length} &lt;/small&gt; &lt;/div&gt; )}/&gt;// virtual-list 组件import React from 'react';import PropTypes from 'prop-types';import styled from 'styled-components';import {List, AutoSizer, InfiniteLoader, CellMeasurer, CellMeasurerCache} from 'react-virtualized';const RowCell = styled.div` position: relative; display: block; overflow: hidden; color: rgba(0, 0, 0, 0.65); font-weight: 400; white-space: nowrap; text-overflow: ellipsis; cursor: pointer;`;const VirtualList = (props) =&gt; { const cache = new CellMeasurerCache({ defaultHeight: 40, minHeight: 0, fixedWidth: true }); const {total, data, handleChange, handleMore, optionText} = props; function RowRenderer(opj) { const {index, key, parent, style} = opj; return ( &lt;CellMeasurer cache={cache} columnIndex={0} key={key} parent={parent} rowIndex={index}&gt; &lt;RowCell style={style} onClick={() =&gt; { handleChange({index: index, item: data[index]}); }} &gt; {optionText(data[index], index)} &lt;/RowCell&gt; &lt;/CellMeasurer&gt; ); } function handleHeight(height) { return Math.min(data.length * cache.defaultHeight + 40, height); } return ( &lt;AutoSizer style={{minHeight: 'max-content'}}&gt; {({width, height}) =&gt; { return ( &lt;InfiniteLoader isRowLoaded={({index}) =&gt; { return index &lt; data.length; }} loadMoreRows={() =&gt; handleMore()} rowCount={total} threshold={2} &gt; {({onRowsRendered, registerChild}) =&gt; { return ( &lt;List height={handleHeight(height)} onRowsRendered={onRowsRendered} ref={registerChild} rowCount={data.length} rowHeight={cache.rowHeight} deferredMeasurementCache={cache} rowRenderer={RowRenderer} width={width} /&gt; ); }} &lt;/InfiniteLoader&gt; ); }} &lt;/AutoSizer&gt; );};VirtualList.propTypes = { handleMore: PropTypes.func, handleChange: PropTypes.func, optionText: PropTypes.func, data: PropTypes.array, total: PropTypes.number};VirtualList.defaultProps = { handleMore: () =&gt; {}, handleChange: () =&gt; {}, optionText: () =&gt; {}, data: [], total: 0};export default VirtualList; demo: https://bvaughn.github.io/react-virtualized/#/components/Table 另外：可参考https://github.com/bvaughn/react-window同一个作者，体积更小，更快。demo: https://react-window.now.sh/#/examples/list/fixed-size","link":"/0fe45faebdb4/"},{"title":"为什么说数字输入框是最最难用","text":"译文原文：https://stackoverflow.blog/2022/09/15/why-the-number-input-is-the-worst-input/译文作者：Jared Toporek 为什么不建议用 1234&lt;input type=\"number\" id=\"id_here\" value=\"sad\" /&gt;const numberInput = document.getElementById(\"id_here\");console.log(numberInput.value); // 打印出 \"\" https://codesandbox.io/s/funny-sky-tfjok3?file=/index.html 数字输入将允许用户输入无效的数字值，但实际上无法检索无效的值 所以，当我们用户输入后，只是提示用户输入无效，而不能精准告诉用户该怎么做，我们大多数人都会感到烦人，用户体验差多了，使用JavaScript进行此类验证绝对是必不可少的。 有效数字不仅包括数字（即，像字母e这样的科学符号） 如果数字输入值增加了足够大，则某些浏览器将自动将您的输入转换为指数符号。 最小/最大属性可以轻松绕过检验 增量/减少按钮将使数字值在这些范围参数内。但是，结果是超过也没有任何提示，还是输出了值 不同的浏览器接受不同的字符。 所有浏览器都不一样。让我们从最佳情况开始。 Chrome、 Microsoft Edge浏览器 允许下列字符 （0-9、小数点.、负值-、指数符号的字符“+”和“ e”） 这两个浏览器都将阻止您多次输入接受的非数字字符。但是，您可以将这些符号放在输入中的任何位置，例如将负符号放在数字之间，这会使数字无效 火狐浏览器 and Safari 没有任何限制。您可以输入任何想要的内容。 所有这些浏览器都会显示一个内置的弹出窗口，以表明输入的值不是有效的数字，并且如果没有用户固定这些输入值，则无法点击提交按钮。内置验证在视觉上与为应用程序构建时的UX设计稿不一致。作为程序员，您可能会发现这是可以接受的，但是设计师和/或产品经理很可能不会。 有没有替代方案呢在详细介绍何时使用数字输入之前，许多经验丰富的程序员知道的东西很重要：在处理数学相关的数字值时，即产品数量或人的年龄时，您才应使用数字输入。其他场景就不适宜了。 如果您要处理有条件的验证或该数字用于计算时，果断放弃数字输入吧。关于如何处理此问题有几个选择： 文章提到了一个可能的解决方案：使用&lt;input type =“ text” inputmode =“ numeric” pattern =“ [0-9]*”&gt;对于整数来说是一个不错的选择，但对于浮点而言不起作用十进制数字。 使用input type=\"text\"，会失去增量/减少按钮。但是，权衡之下，确实是最佳的选择。 这里得到的收获就是不可能提供许多项目要求的同时使用数字输入的复杂功能。这是一个/或选择，而我看到的方式，最好放弃数字输入。","link":"/9dc3b807ceab/"},{"title":"在家就可以实现环游世界的愿望","text":"十一出游的人那么多，人头攒动，有没有和我一样，因为口罩，没有出门，不敢出门的小伙伴？ 下面给大家罗列了几个网站，让你实现躺着就能欣赏远方的风景、世界各地的文化遗产、城市风光、人气景点，足不出户就能在家实现环游世界哦！ https://zh-cam.com/ https://www.skylinewebcams.com/ https://worldcam.eu/ https://www.worldlivecamera.com/en/webcam/The-Deck-Sydney.html https://livechina.cctv.com/zhibo/index.shtml?spm=C04362.PWdejIOEISE0.EVbEpxjQVGbO.2","link":"/41212b74ab17/"},{"title":"如何免费快速搭建一个在线购物商城","text":"我们都知道，全球有四分之一的网站是使用 WordPress 搭建的。用PHP编写并使用 MySQL 数据库的开源网站创建平台，它可能是当今最简单，功能最强大的博客和网站内容管理系统（CMS） 在本文中，如何使用WooCommerce和WordPress进行搭建购物商城。 全程不超过半小时。 零开发基础 环境 windows 10 XAMPP WordPress 下载WordPress https://cn.wordpress.org/download/ 下载XAMPP https://www.apachefriends.org/zh_cn/index.html 安装XAMPP双击安装XAMPP一直下一步，完成后，将wordpress-6.1.1-zh_CN解压重命名wordpress，放置xampp\\htdocs文件夹内 启动WordPress点击【start】,启动 Apache 和 MySQL 点击 MySQL 的 “Admin” 选项，打开 phpMyAdmin，新建数据库 wp 安装WordPress浏览器打开 http://localhost/wordpress 配置WordPress有过万种免费的主题(网站样本)给你用。只要你去外观 (Appearance)及点击主题 (Themes)来搜索就可以安装你想要的主题。我们这里只需要2个插件满足基本需求了。 安装插件WooCommerce 安装主题Joyas Shop 添加商品，编辑店铺 你可以添加产品，装饰店铺，添加支付方式，物流组件，单个商品页编辑等等。 推荐插件 Payment gateways – 这些扩展组件可以接受更多的付款方式。通常，接受的付款方式（支付网关）越多越好。 WooCommerce Subscriptions – 让客户订阅你的商品或服务，并按每周、每月或年费的方式支付 Wordfence Security – 很强大的安全软件，能够扫描网站文件，发现安全隐患并给出设置建议，具有防火墙，防爆破等功能 Autoptimize – 压缩JS文件，减少请求数和文件体积，优化传输速度 完成除此以外，您还可以搭建一个博客网站，企业pages，设计师同学可以做一个作品集网站，论坛网站，视频学习网站等等，期待您的发现。","link":"/1325858d7087/"},{"title":"如何同步并管理我的文章","text":"为什么要搭建技术博客前几日在平台看到这个文章中文互联网的产出在渐渐枯萎吗？，深有感触，知乎这个平台的出现，早期的时候沉淀了许多优质的用户和文章，后来商业化后渐渐的对我没有吸引力了。我不知道多少人喜欢微信公众号，反正我很是讨厌，太封闭，限制太多，发布后就不让修改，也不让添加外链，不能RSS，也无法在网站搜索文章等等。自问也没有能力改变这个营销号漫天飞的环境，很喜欢电影《无问西东》中台词： 世俗这样强大，强大到生不出改变它们的念头来。可是无论外界的社会如何跌宕起伏，都对自己真诚，坚守原则。内心没有了杂念和疑问，才能勇往直前。这个世界缺的不是完美的人，而是从心底给出的真心，正义，无畏与同情。不要放弃，对自己的思索，对自己的真实。 做自己认为有价值的事情，一直坚持去做。这就是我的理由。 写文章是痛苦的，通常一周也就2篇文章的输出，每次花费5个多小时，写完还要审查下有没有错别字，配图是不是合理，文章通常改了又改，后续补充又补充。为了逼自己输出内容，不得不去看东西学新东西，读书、看源码、听播客，然后把自己遇到的、自己处理的解决方案写下来，通常还要把环境再重装一次，项目再重新创建一次，折腾来折腾去。 在完成主业的同时，研究着些小项目、开源项目等等，以前写进代办事项落灰的清单也在慢慢被清除，目前看下收获也算颇丰了，除了能力的提升，还有精神上满足感，不再焦虑，生活质量也提高不少。 我是如何管理博客的和很多技术人员一样，我酷爱使用软件vscode来编辑md,步骤点此：如何零成本搭建一个博客，然后通过自己用js写的脚本手动更新并同步到各个平台。 1\"publish\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; node async.js\" 如果你不是技术人员，你可以使用下面这个同步工具 同步工具微信公众号同步助手 在官网下载安装包，安装插件后，在网页右击-提取文章并同步 如果没有登录，可以直接去网站登录，后面再次点击同步就出现这个网站图标了，操作起来还是很顺畅的。 但是同步后只是到草稿，还不是正式发布，需要手动，感兴趣去官网看看吧。 目前已经支持：20多个平台 免费图床写文章最怕什么，微信公众号封面要配图，文章首页要配图，内容排版要加图吸引用户。俗话说一图胜千言，但是找图实在是累死人的活儿，下面推荐几种免费可商用的网站。 笑果图床 支持外链，无限空间，无限流量, 无需登录即可上传，最大支持10M的图片 Pexels 是一家国外的免费高清图片网站。适合寻找风景图和各类职场、商业场景大图。 Unsplash 想寻找一些高质量的高逼格的图片，不妨到这个网站来试试。 聚合图床 笑果图床是我一直在用的，不得不说页面不是很好看，但是服务一直稳定，也就没替换了。 一般配合Pexels和unsplash在一起用，数量上不如Pixabay，但是质量很高。 你可以：在电脑上写完文章后，把配图一次性上传到笑果图床，在网站上把生成的html页面再粘贴到公众号，无需再一个个上传到微信公众号了，很是方便。 技术人爱逛的网站 优质独立博客 中文独立博客列表 https://github.com/timqian/chinese-independent-blogs 优秀的技术网站 Hacker News v2ex medium 博客园 有哪些值得邮件订阅的网站 Hacker News JavaScript Weekly 每周一封，关于JavaScript的新闻和文章 Frontend Focus 最佳前端新闻，文章和教程的周刊综述。HTML，CSS，WebGL，画布，浏览器技术等。 Node Weekly 免费的，每周一次的免费电子邮件汇总。 ES.next News 最新的ES知识推送 React Status React UX Design Weekly 每周最佳用户体验设计 Daily UI cssweekly CSS每周一次 InfoQ 每周精要 Medium Digest 如果你也想搭建一个网站：如何零成本搭建一个博客，不妨看下此文。 原文：https://xuxia2013.github.io/%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E5%B9%B6%E7%AE%A1%E7%90%86%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0/","link":"/464d957066f2/"},{"title":"如何零成本搭建一个博客","text":"介绍怎么搭建一个网站，如何发布，如何同步到其他平台，如何管理我的文章。 挑选一个喜欢的主题先去网站 https://hexo.io/themes/ 逛逛，应该会花费不少时间。一个美美的网站才是源动力吖。 我选了这款：很有质感，简约而有内涵。 https://github.com/ppoffice/hexo-theme-minos Github账户GitHub作为最大的全球交友网站，人手必备一个。 创建一个库 https://github.com/new 此处必须一直，如果你账户是张三，也必须输入张三 安装hexo npm install -g hexo-cli hexo init [yourBlogName] cd [yourBlogName] &amp;&amp; npm install 安装主题 git clone https://github.com/ppoffice/hexo-theme-minos.git themes/minos 本地搭建 hexo s 浏览器打开网页：http://localhost:4000 部署 连接github: _config.yml 1234deploy: type: 'git' repo: https://github.com/[yourBlogName]/[yourBlogName].github.io.git branch: 'main' hexo clean 清理缓存 hexo g 生成页面 hexo d 部署 初始化完成 快快打开 [yourBlogName].github.io.git欣赏下吧。。 写文章 写一篇文章 hexo new post \"article title\" 写一篇草稿 hexo new draft \"article title\" 发布文章 hexo p \"article title\" 添加评论 申请LeanCloud账号并创建应用 进入该应用的 设置-&gt;应用凭证，找到 AppID 和 AppKey，记录下来后面配置要用 themes\\_config.yml下配置 123456789101112# # Comment plugin settings.comment: type: valine app_id: [appid] # (required) LeanCloud application id app_key: [appkey] # (required) LeanCloud application key notify: false # (optional) receive email notification verify: false # (optional) show verification code placeholder: # (optional) comment box placeholder text avatar: hide pageSize: 10 # pagination size visitor: true 百度统计访问量 登录百度统计， 定位到站点的代码获取页面 编辑 主题配置文件， 修改字段 baidu_analytics 字段，值设置成你的百度统计脚本 id 12345678910// `themes\\_config.yml`下配置plugins: mathjax: true katex: false gallery: true clipboard: true google-analytics: tracking_id: baidu-analytics: tracking_id: // [复制 hm.js? 后面那串统计脚本 id] 添加打赏 写一个插件donate.ejs 放在页尾 123456789101112&lt;% if (!index &amp;&amp; has_config('donate') &amp;&amp; get_config('donate') === true&amp;&amp; url_for(page.path) !== '/about/index.html' ) { %&gt; &lt;div id=\"donate\" style=\"text-align:center; margin-top: 60px;\"&gt; &lt;%- get_config('donate_message') %&gt; &lt;br/&gt; &lt;img src=\"&lt;%- url_for(get_config('donate_wx_img')) %&gt;\" alt=\"\" style=\"margin-right: 40px;\"&gt; &lt;img src=\"&lt;%- url_for(get_config('focus_wx_img')) %&gt;\" alt=\"\" &gt; &lt;/div&gt;&lt;% } %&gt; 在配置文件中配置 123456#是否开启打赏donate: true#打赏文案donate_message: 欣赏此文？求鼓励，求支持！donate_wx_img: 打赏微信图片地址focus_wx_img: 关注公众号图片地址 知识版权https://creativecommons.org/licenses/by-nc-sa/4.0/配置在网站最底部。 原文：https://xuxia2013.github.io/%E5%A6%82%E4%BD%95%E9%9B%B6%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/ 添加域名可以在Github对应repository的Setting里，找到Github Pages， 在Custom domain里填进去自己的域名，保存。你会发现在repository里，会多出一个名为CNAME的文件，内容是自己的自定义域名的网址。在Hexo目录里的source文件夹下面，新建一个同样内容、同样名字的CNAME文件即可。 不然你每次Hexo推送GitHub Pages时，会遇到自定义域名失效问题","link":"/853e3c088dac/"},{"title":"嵌入式持久性数据库 —— Nedb","text":"简述 是什么？数据库。 特点： 适用于 Node.js，nw.js，Electron 和浏览器的嵌入式持久性数据库或内存数据库，JavaScript，无二进制依赖性。API 是 MongoDB 的子集，并且速度非常快。可以充当内存数据库，也可以用来实现本地存储 能干什么 ？ 消除了与客户机服务器配置相关的开销，在运行时，也只需要较少的内存开销 缺点：不宜用于处理大量数据 性能：NeDB 吞吐量 (带索引) Insert: 5950 ops Find: 25440 ops Update: 4490 ops Remove: 6620 ops 安装 https://github.com/louischatriot/nedb ❤10.7K 12345npm install nedb --save # Put latest version in your package.jsonnpm test # You'll need the dev dependencies to launch testsbower install nedb # For the browser versions, which will be in browser-version/out 开始123456const Datastore = require('nedb');const page = new Datastore({ filename: './[dbname].db', autoload: true,}); 简单教程查找： 12345db.find({}, function (err, docs) {}).sort().limit();db.findOne({ \\_id: [id] }, function (err, docs) {});db.count({id: [id]}, function (err, count) {}); 插入： 1db.insert(doc, function (err, newDoc) {}) 更新： 1db.update({ \\_id: [id] }, { $set: { replaceObj } }, { multi: true }, function (err, newDoc) {}) 删除： 123db.remove({ \\_id: [id] }, {}, function (err, numRemoved) {// numRemoved = 1}); 坑执行 update 和 remove 操作时，nedb 都会在文件末尾新增加一行相应数据，确实产生了重复的数据再去查询这个数据库时数据是正常的，没有重复，当我再次重启时，db 数据多余的数据消失。（神奇~~~~ ） 注意 NeDB 支持索引。索引可以提高查询速度以及保证字段的唯一性。索引可以用在任何字段，包括嵌套很深的字段，能用来加速基本查询以及使用 $in, $lt, $lte, $gt 和 $gte 运算符的查询 数据库会自动被压缩，可手动 区分大小写 其他数据库 lowdb https://github.com/typicode/lowdb ❤11.7K 支持 node.js 和浏览器端的使用， 和 Lodash API 一致 lokijs https://github.com/techfort/LokiJS ❤5K 支持 js 和浏览器端的使用 借鉴 http://www.alloyteam.com/2016/03/node-embedded-database-nedb/","link":"/caaf024d487a/"},{"title":"微信开发-eggjs后台上传素材","text":"最近在研究微信开发，做了一个平台，但是上传素材至微信服务器频频出现问题，各种尝试后，最终解决了，特此记录下。 话不多说上代码： 前端代码前端采用 element-ui/el-upload 123456789101112131415161718192021222324252627&lt;el-upload action=\"/dev-api/upload\" :file-list=\"form.thumb\" name=\"media\" list-type=\"picture-card\" :auto-upload=\"true\" :headers=\"headerObj\" :on-change=\"handleChange\"&gt; &lt;i slot=\"default\" class=\"el-icon-plus\" /&gt; &lt;div slot=\"file\" slot-scope=\"{ file }\" class=\"thumb-img\" :style=\"'background-image: url(' + file.url + ')'\" &gt; &lt;span class=\"el-upload-list__item-actions\"&gt; &lt;span class=\"el-upload-list__item-delete\" @click=\"handleRemove(file)\" &gt; &lt;i class=\"el-icon-delete\" /&gt; &lt;/span&gt; &lt;/span&gt; &lt;/div&gt;&lt;/el-upload&gt; 效果： 后台代码后端采用egg.js config/config.default.js 12345678910multipart: { mode: 'file', fileExtensions: [ '.jpg', '.jpeg', '.png' ], }, security: { csrf: { // 判断是否需要 ignore 的方法，请求上下文 context 作为第一个参数 ignore: ctx =&gt; isInnerIp(ctx.ip), }, }, controller/upload.js 1234567891011121314151617181920212223242526// UploadController方法// 引入库const formstream = require('formstream');// 获取tokenconst access_token = await service.weixin.token(settingOne);// 文件处理const file = ctx.request.files[0];const imgbase64 = await fs.readFileSync(file.filepath, 'base64');const dataBuffer = Buffer.from(imgbase64, 'base64');const form = formstream();form.buffer('media', dataBuffer, file.filename, file.mime);// 上传至微信服务器 - 新增永久素材const { data: result } = await ctx.curl(`https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=${access_token}&amp;type=image`, { method: 'post', headers: form.headers(), stream: form, dataType: 'json',});if (result.errcode) return ctx.helper.error(ctx, 500, result); ctx.helper.success(ctx, null, '上传成功'); 大功告成！撒花💖","link":"/a692a0d2707e/"},{"title":"技术出身的能做好管理吗？","text":"都说30岁是个坎，这话果然不错，30岁之前，我对自己的职业定位是在前端领域里继续深耕，个人技术能力再升级最终走向，架构师、CTO的终点，还可以继续写自己的页面，写个十年，二十年，在上海安家养老。 那个时候，在前端组组内还是挺舒服的状态，成员彼此很熟悉，经常在一起讨论技术，沟通问题，薪资还算不错，经常加班加点，也是小有成就，独立做项目，独立和产品沟通，和上下游同事打成一片，有时间自己去徒步，参加技术线下活动，时光温柔安静，一切都朝着自己的梦想前进着。 也算是运气好，遇到值得相守此生的人，再加上遇到公司内部大调整，我知道自己可能是时候去过另外一个人生了，其中还是有很多纠结过难熬过这里就简单带过了。结完婚，去三亚拍婚纱照，云南度完蜜月，再加上一直没有时间请的假，婚假期，闲闲散散的国内玩了好几个月，轻松甜蜜。后来选择在浙江定居下来了。 新婚后生活总是新奇的体验，安定下来后，我开始找工作，一开始只想先找个大公司先熟悉下来，毕竟环境大大的不一样，也怕自己适应不下来，先有份工作再说，因为这里不再有熟悉的前同事，前领导，没有一点点人脉，然后自己投简历，幸运的是很快就找到第一家公司，说是要的薪资太高，最终没有谈拢，我开始调整自己的心态，多做些调查和打听，第二次面试后顺利的入职了。一周后上手项目做业务了，也熟悉了技术栈和团队的大概情况。 跟很多做技术的一样，领导直接安排你做负责人，负责技术选型和难点敲定功能点，把控前端项目，前端团队的任何事情大家都开始来找我，再加上做技术的大部分都不太喜欢跟人打交道，我也是不喜欢的，首先沟通的工作是最累人的，而且花时间还没有成效不如自己敲代码来的实际，再加上我偶尔有点小脾气，在这条技术管理的路上开始遇到了坎坷。。。 然而现在我也非常热爱现在的团队，找到了新的自己，团队管理也算略有心得，这里跟大家分享一二。 角色转变认同价值认同管理的价值，认同组内成员输出的价值 你不再是一个单打独斗的英雄，而是团队负责人，思维从“工程师” 转成“产品经理”，不仅要对自己手头上的工作负责，还要带领整个团队前进，对自己领导负责，对下属负责，三方的目标要达到一致。 在了解领导的要求和规划后，合理安排任务，倡导自由领取任务和允许跨端开发，给予研发上自由和鼓励创新的新想法。以结果为导向，任务划分详细，交代任务背景和要求，提出自己的方案来引导其他人思考，或者大致给出方向，再给与风险评估，可行性评估在下属遇到难点卡点的时候协助一二，多去问他们都做了哪些尝试，肯定下属付出的同时，给与他们足够的信任和尊重，加以肯定和鼓励，同事之间遇到沟通上的问题时，优先在情绪上要多安抚和疏通，然后在一起讨论，带有情绪的工作都是无济于事；任务多的时候，难免大家都有意见，会先跟领导提出目前规划，遇到的问题，自己的解决办法，让领导抉择，压力大的时候，任务安排的合理性就很重要了。对上要能抗住事，不把太多压力释放到下属这层，对下要严谨认真，把事情安排妥当，规划好时间，任务拆分还要聚合任务，完成一个整体。在下属取得不错的进步后，大方的在公司群里或者领导目前多提，在项目出现问题时，自己主动来沟通接盘，安排处理解决及时上报进度和处理方案得到理解和支持。再用一些市面上比较成熟的管理工具，配以管理项目，更是事半功倍。 认同下属的工作价值，认同管理的价值，相信 1 + 1 + 1 &gt; 10的效果。 带头作用一开始的时候前端项目优化，新插件，工具，功能复杂的业务都是自己来做，把一些好的习惯，代码风格，编写格式融入具体业务中，让员工学会“偷懒”，体会简洁的代码的舒适感，编译速度提升带来的滋润，逐渐养成书写技术文档的习惯，后面从一手包办的保姆角色变成”你也可以去做”，你的想法比我的更好，甘心做一个垫脚石，在业务中把自己知道的”知识、眼界”全盘奉献出去后，来激发他们能力的释放。我深知，按部就班的管理是不会带来业务增长的，下属的好奇心、成就感才是内驱力。激发思考，思考后实践，得到收获后不言而喻的心满意足会变成内循环，不断滋润组内每一个人。在下次其他同事遇到问题，我知道，肯定有人会主动去想这怎么去弄，虽然这可能跟我工作无关。 技术和管理如何兼顾我相信自己可以写代码写到80岁的人，有点狂妄，但是却是心里所想。在管理的同时，我发现自己很多短板，在上海，工作细分化很多工作我无需关心，只要做好自己的工作也能带来很高的报酬。但是做了管理时间长了，我渐渐发现只专注于前端还不够，你需要懂整个框架，业务框架，后端架构，满足业务后呢，客户还需要什么功能呢？前端领域知识很庞杂，各种框架林林总总很多，总是要跳出来看看，业务还需要什么？技术总有优缺点，寻找更合适的技术去搞定业务，贴合需求。这些经历会让我打开自己，发现技术的海洋还如此广阔，而自己懂的还不够，不局限于某一技术栈，迫使自己站在更高视角使用技术，更深入的去了解其他成熟的技术架构，更多的选择空间让我在30岁这个焦虑的年纪多了很多信心和感动。 管理风格你想做一个什么样的领导，取决于你自己。我不知道其他人怎么看我，对公司来说，能解决问题就有价值。不管是人的问题还是事情的问题，能解决问题就是好员工。自己怎么解决问题的，很多时候都是自己看到学来的。很久前那会刚毕业，遇到非常不错的上司，交大毕业，现在研究比特币，英文名是alex xu，曾带我一段时间，很感激有一位很优秀的领导，教会我很多东西，如何挖掘用户最真实的需求，技术管理，代码怎么样算好代码，也真正做到了甘当人梯，给我很多的启蒙指导。我也希望自己有天也可以同他做一位不错的领导。 拥抱变化离开呆了十年的大上海后，发生了很多变化，再加上疫情，心态也发生了很多转变，对高性价比的生活有了新的感悟和方向。我开始关心以前不愿意看到的事情，也在慢慢在意合融入，关心并处理复杂的人事，花时间去观察形形色色的人，协调多方资源，驱动整个组织和系统来运转，这些都还在学习中…","link":"/1cd3e420554a/"},{"title":"搭建组件私有仓库","text":"Git仓库当私有npm我们通常通过 npm 来安装和使用开源的库。但是，通常我们有些私有的模块，更新不频繁，不想通过npm发布，但是又想在多个项目中使用，同时我们不想将组件库复制到各个项目中来使用。而且一旦公有模块更新，我们也不能及时更新。 利用现有的git，既不用搭建私有的npm私有仓库，又能满足上面的需求，它做为一个快速解决方案, 后期是可以慢慢过渡升级到使用完整 npm 私有仓库项目地址：http://[ip]/wonders-ui 私有组件库搭建安装1\"@wonders-ui/mobile\": \"git+http://[ip]/wonders-ui/mobile.git\" 使用1234import Vue from 'vue'import wondersUI from '@wonders-ui/mobile'Vue.use(wondersUI) 注意不好的地方是，使用 npm update / yarn 是无法更新这个@wonders-ui/mobile”，想更新只能重新安装一次，或者使用下面命令。 1yarn add git+http://[ip]:[password]@[ip]/wonders-ui/mobile.git 管理组件库@wonders-ui/web使用storybook来管理组件库 简述 可以帮助构建 UI 组件，组合组件，说明文档，测试和部署 UI 组件的工具，与业务功能隔离开来，专注于开发组件。 支持框架 React，Vue等 提供丰富的插件供开发使用，比如docs可以生产组件参数说明（参数描述，参数定义，支持的类型等）， knobs 帮助您在隔离构建UI组件时 可以动态地修改组件的参数来验证交互; notes可以展示你的md文档； addon-storysource可以直接在页面看到你的源码；一键生成所有截图的Storybook Chrome Screenshot Addon。这些社区的addons都非常实用。感兴趣可以自己增加 支持模拟不同设备下的组件 jest自动化测试组件还有依靠视觉,快照和视觉回归测试 灵活度很高，如果想使用js/ts，css,/scss/styled-components, redux 都是可以的，在其他组件库基础上进行二次开发，需要自行配置项目 运行 git clone yarn yarn storybook","link":"/19ad579dc527/"},{"title":"如何基于Vue快速搭建可视化大屏平台","text":"我们公司一直都有做大屏的业务需求，对于客户有数据监控，实时能观测海量数据，酷炫的动态图表，在大屏上展示更生动和震撼，效果好到炸裂 1. 首选阿里DataV数据可视化 DataV提供图形化编辑页面，使用简单拖拽的方式即可完成多种样式和数据配置，无需编程就能轻松搭建。定制了能源、电力、医疗、零售、制造、气象、教育、旅游、物流、互联网等多个行业数据模板。 内容丰富，轻松上手，入股不亏~ 新用户短期9.9搞定。 2. 积木报表http://www.jimureport.com/bigscreenIndex 微信登录后，可免费使用 3. iGaoWei/BigDataView如果你还是想自己捯饬，也有很多免费的模板下载100套大数据可视化炫酷大屏Html5模板；包含行业：社区、物业、政务、交通、金融银行等，全网最新、最多，最全、最酷、最炫大数据可视化模板 纯h5静态代码，参数接口还是要自己来写写代码的。 4. jackchen0120/vueDataV基于vue的新各行各业实用模板和炫酷小组件，有能力开发的话可以自行配合使用 5. DataV-Team/Datav 7.5K一个基于Vue的数据可视化组件库，通过组合不同的配置项可以达到多变的视觉效果 同时有第三方开源库：Echarts（百度），AntV，Highcharts，D3.js，three.js等Echarts相对简单些，容易上手，很多项目二次开发。 各位看官自行取舍。 延伸阅读 大屏做成这样，领导想不重用你都难！https://zhuanlan.zhihu.com/p/28557620","link":"/992d13211977/"},{"title":"无问西东","text":"世俗这样强大，强大到生不出改变它们的念头来。可是无论外界的社会如何跌宕起伏，都对自己真诚，坚守原则。内心没有了杂念和疑问，才能勇往直前。 这个世界缺的不是完美的人，而是从心底给出的真心，正义，无畏与同情。什么是真实，做什么和谁在一起，你看到什么听到什么，有一种从心灵深处满溢出来的不懊悔也不羞耻的平和与喜悦。 看到和听到的，经常令你们沮丧，世俗是这样强大，强大到生不出改变它们的念头。可是如果有机会提前了解了你们的人生，知道青春也不过只有这些日子，不知你们是否还会在意的事情，比如占有多少，才更荣耀，拥有什么，才能被爱。 等你们长大，你们因绿芽冒出土地而喜悦，会对出生的朝阳欢呼雀跃，也会给别人善意和温暖，但是却会在赞美别的生命的同时，常常，甚至永远忘了自己的珍贵。 愿你在被打击的时，记起你的珍贵，抵抗恶意；愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。 不要放弃，对自己的思索，对自己的真实。","link":"/e8e45e38c7b4/"},{"title":"浅谈uniapp","text":"我们团队使用uniapp + uview 开发了10个小项目，业务相对不复杂，实现了普通的客户终端业务，比如代办列表，新闻资讯，个人app业务管理，人脸识别，在线直播通话等。 也许大家都没有接触过这个跨平台的前端框架。先简单介绍下。 官方文档说，uni-app在开发者数量、案例、跨端抹平度、扩展灵活性、性能体验、周边生态、学习成本、开发成本等8大关键指标上拥有更强的优势。 开发者和案例更多：HBuilder装机量800万台，开发者社区月活百万，70多个QQ微信群承载10万人。案例众多，uni统计月活超10亿（点击） 性能更高（见评测） 更丰富的周边生态，插件市场数千款插件 提供比小程序原生开发更好的开发体验、更高的工程化效率 跨端抹平度更完善，且各端特色发挥更灵活，可真正实现一套代码6. 多端覆盖，无需各端多头维护升级 权威认可：阿里小程序官方工具内置uni-app（点击）、腾讯课堂官方自制uni-app培训视频（详见） 我的感受是，如果你团队资源有限，没有细致化的需求，有一个前端就能搞，成本低，上手很快，效果快。如果你的老板想法很多，客户需要一个程序员就能搞定开发的，如果你的产品说，搞app比较来钱，选这个就对了。 来点正经的哈 编辑器难用，跟vscode资深用户说换编辑器本身就是要命的，更何况官配的HBuilderX，设置主题啥，字体啥难看死掉，时常崩溃没响应，只能退出去重新打开。 打包一天就7次，可以付费打包（一个包2元，骗我钱 uniCloud最好别用，限制多，（个人崇尚开源免费 踩到坑了，社区很少会回复你的，插件市场很多插件没错，但是大部分是个人app开发，回复和修复问题的速度你懂的，大家都是有工作有生活的。然后你的开发进度就卡在那儿了，坑只能自己含着泪给填了…… 总而言之，不停的探索，总有意想不到的收获。","link":"/11ea0d754414/"},{"title":"深入学习flutter(零)","text":"前几日，看到某公众号给我安利用flutter来做游戏，Flutter 3.0 新出了对游戏很友好，流畅度极高，与原生效果相差无几。同时还有对广告、应用内购买和游戏中心等服务的预构建集成，想起几年前就对flutter有所耳闻，一直也没有时间来学习，现下正合适。你问为什么对游戏感兴趣？因为上一家公司就是跟游戏相关，就是说特别能赚钱吧。 学习新东西总是痛苦的，总是要逼自己去学习，不然脑子渐渐就不好使了。希望对你有帮助。 安装1git clone https://github.com/flutter/flutter.git -b stable 配置环境变量12PUB_HOSTED_URL=https://pub.flutter-io.cnFLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 安装vscode安装flutter dart 测试是否安装成功1flutter doctor 新建项目ctrl + shrft + p 启动任务栏，输入flutter, 选择新建项目即可。 成功了~ 其他阅读 Flutter 3.3发布，带来新的预览版渲染引擎 初探Flutter跨端游戏开发 学习资料Flutter中文网https://flutterchina.club Flutter实战https://book.flutterchina.club Flutter社区http://www.flutter-io.cn Flutter每周Widgethttps://www.youtube.com/playlist?list=PLjxrf2q8roU23XGwz3Km7sQZFTdB996iG 资源整合https://www.jianshu.com/p/f5a4a28e2888","link":"/185bfbae2328/"},{"title":"用uniapp开发一个新闻小程序","text":"目前市面上各种「跨平台」开发解决方案层出不穷，比较有代表性的就是： UniApp、Flutter、 React Native、Taro、Weex等等。UniAPP 是基于「 Vue + 微信小程序 」语言体系，开发人员学习成本低上手快，对于是很多中小型企业，因为短小快，省去很多人工成本，也不失为最佳的选择。很多政企项目也开始使用了：案例 此前，本人是博客园的深度用户，也苦于没有安卓小应用，做了一个小程序。每天刷刷看文章。使用了官方开发接口，没有后端和数据库，0成本做了一个使用频繁的微信小程序，感兴趣就往下看吧 成果 准备 cnblogs API KEY 申请：https://oauth.cnblogs.com/ 注册一个微信小程序 地址 api接口文档：https://api.cnblogs.com/help 开发工具 微信开发者工具 [uniapp官方编辑器](https://www.dcloud.io/hbuilderx.html) 学习路线没有接触过 Vue.js，有 html、css、JavaScript 的基础也可以如果你有过h5、原生小程序、mpvue等的开发经验，也可以无缝衔接到 uni-app，几乎没有额外的学习成本 大体了解Vue.js 语法 学习创建运行 uni-app 项目：了解 uni-app 组件、路由等知识，开发过程中需要注意的是uni-app中对vue语法的兼容性 学会使用官方工具 HBuilder 自己开发个小功能看看效果 根据项目情况，继续补充 ES6、NPM 等知识 项目打包并上线到各平台 创建项目在点击工具栏里的文件 -&gt; 新建 -&gt; 项目：输入项目名称，项目地址 创建完成后目录结构如下 添加uni-ui打开连接；https://ext.dcloud.net.cn/plugin?id=55 点击导入插件： 出现uni_modules文件夹： 配置登录微信小程序后台 开发者-开发管理-开发者ID (AppID 小程序ID、AppSecret小程序密钥 ) 小程序代码上传-IP白名单添加本地ip 服务器域名-request合法域名: https://account.cnblogs.comhttps://api.cnblogs.com token1234567891011121314151617181920212223242526272829303132333435363738394041424344async function getToken() { const token = await requestFn({ url: '/token', method: 'POST', data: { client_id: '', client_secret: '', grant_type: 'client_credentials' }, header: { 'content-type': 'application/x-www-form-urlencoded' } }) uni.setStorageSync('token', token.access_token); uni.setStorageSync('expires_in', token.expires_in); uni.setStorageSync('expires_in_start', moment().valueOf());}const baseUrl = 'https://api.cnblogs.com';async function requestFn(options) { return await uni.request({ ...options, url: baseUrl + options.url, header: { ...{ 'Authorization': `Bearer ${uni.getStorageSync('token')}` }, ...options.header }, }).then(res =&gt; { // console.log(res, 'res') const data = res[1] if (data.statusCode == 200) { return data.data } uni.showToast({ title: data.data.title, icon: 'none', duration: 4000 }); return data.data })} page.json 1234567891011121314151617181920212223242526272829303132333435{ \"pages\": [ { \"path\": \"pages/index/home\", \"style\": { \"navigationBarTitleText\": \"代码改变世界\" } }, { \"path\": \"pages/index/details\", \"style\": { \"navigationBarTitleText\": \"博文\" } }, { \"path\": \"pages/index/author\", \"style\": { \"navigationBarTitleText\": \"\" } }, { \"path\": \"pages/index/search\", \"style\": { \"navigationBarTitleText\": \"找找看\" } } ], \"globalStyle\": { \"navigationBarTextStyle\": \"black\", \"navigationBarTitleText\": \"uni-app\", \"navigationBarBackgroundColor\": \"#F8F8F8\", \"backgroundColor\": \"#F8F8F8\", \"onReachBottomDistance\": 200 }} 首页12345678910111213141516171819202122&lt;template&gt; &lt;view class=\"tabs\"&gt; &lt;scroll-view id=\"tab-bar\" class=\"scroll-h\" :scroll-x=\"true\" :show-scrollbar=\"false\" :scroll-into-view=\"scrollInto\"&gt; &lt;view v-for=\"(tab, index) in tabBars\" :key=\"tab.id\" class=\"uni-tab-item\" :id=\"tab.id\" :data-current=\"index\" @click=\"ontabtap\"&gt; &lt;text class=\"uni-tab-item-title\" :class=\"tabIndex == index ? 'uni-tab-item-title-active' : ''\"&gt;{{ tab.name }}&lt;/text&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;view class=\"line-h\"&gt;&lt;/view&gt; &lt;swiper :current=\"tabIndex\" class=\"swiper-box\" style=\"flex: 1;\" :duration=\"300\" @change=\"ontabchange\"&gt; &lt;swiper-item class=\"swiper-item\" v-for=\"(tab, index1) in newsList\" :key=\"index1\"&gt; &lt;scroll-view class=\"scroll-v list\" @scroll=\"scroll\" enableBackToTop=\"true\" :scroll-top=\"120\" scroll-y @scrolltolower=\"loadMore(index1)\"&gt; &lt;uni-search-bar v-if=\"isShowSearch\" @confirm=\"search\" v-model=\"keyword\"&gt;&lt;/uni-search-bar&gt; &lt;media-item :listData=\"tab.data\" /&gt; &lt;view class=\"loading-more\" v-if=\"tab.isLoading || tab.data.length &gt; 4\"&gt; &lt;text class=\"loading-more-text\"&gt;{{ tab.loadingText }}&lt;/text&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;/view&gt;&lt;/template&gt; 点赞收藏转发代码123456789101112131415161718192021onShareAppMessage() { return { title: '代码改变世界', path: '/pages/index/home', imageUrl: '../../static/logo.png' };},onShareTimeline() { return { title: '代码改变世界', path: '/pages/index/home', imageUrl: '../../static/logo.png' };},onAddToFavorites() { return { title: '代码改变世界', path: '/pages/index/home', imageUrl: '../../static/logo.png' };}, 运行项目微信小程序运行：进入项目，点击工具栏的运行 -&gt; 运行到小程序模拟器 -&gt; 选择微信开发者工具。 运行后，目录会多一个，这里就是各端编译后的文件：unpackage\\dist\\dev\\mp-weixin 注意：需要打开微信开发工具，然后 设置 -&gt; 安全 -&gt; 服务端口 -&gt; 开启。否则连接接不上。 预览 上传代码通过微信开发者工具发布-审核通过后-后台点击上线 读完全文的你不会找不到源码","link":"/2725a7f66451/"},{"title":"程序员如何优雅地搞副业","text":"技术最大的价值是解决问题和需求。哪里有问题和需求的存在，哪里就有技术伸展的空间，就有盈利的机会，今天想分享些自己对于技术人员业余项目的一些总结和我发现的一些机会。 对于很多程序员来说，一边领着全职工资，经历着 996，根本没多少悠闲时间用来搞搞副业。程序猿都是爱折腾的，应该有不少人跟我一样相信指尖的力量可以改变世界吧，有点时间的话总是用来做些新东西 那我们就接着看。 1.如果你在某个细分领域有一定的专业性，可以在 比如知乎上 简书上 知识星球上以尝试做自己的个人 IP，通过分享自己的课程或者专业知识来来赚取一份副业收入。 兼职外包 开源中国众包 猿急送 程序员客栈 当你看到一个生活周边普通朋友使用电脑或手机时，如果遇到的一些重复性或者技巧性的问题时，动动脑筋，他们的这些问题能不能用技术解决，如果可以的话，去尝试着做一个业余项目。举几个例子： Park.io : 一个帮助你抢 io 后缀域名的网站，每个月目前收入有 13 万美金，真的是一个人的项目哦，很不错吧。 视频音频转换器: 一款很普通的 Android App，帮助用户做视频音频的格式转换，每个月收入有 3000 美金。 Weather Extension：一款纯粹简单的浏览器天气提醒插件，每月收入有 1 万美金。 目前就我所知的最厉害的解决工具型产品案例是 http://www.youtube-mp3.org/ ，一款把 Youtube 视频转换成音频的在线工具。需求蛮奇怪的对吧，只有一个简单的页面，但是你会发现他支持几乎所有国家的语言，再细细研究会发现这个做的很丑的网站居然是 Alexa 前 500 的网站，每天 UV 和京东一个数量级。经过一番研究我发现它的逻辑其实是这样的：每次新音乐上线，发行方都会在 Youtube 放上公开的 MV，让大家试听购买，但是事实是多数用户想在 iPod 上听却不愿意花钱买，那这个网站就把 YouTube 的音乐提取出来咯，一不小心就这么流行了，每天收入可能在 1 万-10 万（可能不准确）美金级别，很厉害吧。 解决问题型的业余项目从工具出发会是个很好的开始，毕竟工具相比于内容来说，并不需要每天持续输出，只需做程序员最擅长的就好了。 另外，思路可以放宽一些，工具不要局限在 App 和 Web 上，也可以是 Wordpress 主题和插件、Chrome\\Safari\\Firefox 插件、WeChat\\Line\\iMessage 收费表情包等等，只要用户忠诚，产品好用，铁定是有用户愿意付费的。 企业内推 有资料显示 滴滴的内推奖励从 D5-D10/M4 以上职级，内推奖金从 4000 元到 60000 元不等，而针对橙心优选的平台运营部岗位“重磅加码”，奖金翻番。在脉脉职言区，网友先后匿名透露企业内推奖金：快手内推 k3 级别奖励约 10000 元，腾讯内推 p9 级别员工奖励 6000 元，字节跳动内推基础岗位大部分奖励 2000 元及以下、2-1 级别员工奖励 5000 元。 如果手上有写人脉 可以尝试看看 回报周期比较长 沟通成本也很高。留意些或许会有一笔意外收入哦","link":"/aa3c2d7f6776/"},{"title":"福利-福晰pdf编辑器激活码","text":"福昕 pdf 编辑器激活码 激活秘钥: 13601-020CF-R1NZ5-SBE8A-9BF8R-B7IMS填写：西南民族大学 地址： http://ms.swun.edu.cn/download/fuxinpdfwin.html 教程","link":"/3b219825206b/"},{"title":"解析package.json文件","text":"在每个前端项目中，都有package.json文件，它是项目的配置文件，常见的配置有配置项目启动、打包命令，声明依赖包等以vue-element-admin项目为例子： https://gist.github.com/xuxia2013/11b22c759bc1a35587c8499f534847d0","link":"/d1720a0fff5f/"},{"title":"老项目vue2+webpack3项目升级教程","text":"去年接手了公司一个项目，前一段时间，收到产品反馈说线上打开菜单非常的慢，点了几个列表页，网站就卡死了，再点击就没有反应了。用的 vue2.6.10 + webpack3 + element-ui2.15.7 项目很大，业务代码中使用了很多体积比较大的库，还有封装了大量的组件。 本地构建花费了 5 分钟，打包完 dist 文件有 16M 这么大，首屏加载大概有 7-8s，打开项目线上地址，我进去一看点了几个页面，果然出现产品和用户反馈的一样，卡顿明显，没几分钟，整个网站卡住了，刷新也还是卡。 那就开始整吧。 如何排查问题 使用 chrome 的开发者工具(打开网站，按 F12) 如何使用可看官网文档，这里不赘述了 https://developer.chrome.com/docs/devtools/evaluate-performance/ Performance Lighthouse Network 勾选 Preverse Log 保留日志，勾选 Disable Cache 屏蔽浏览器的接口缓存机制，No throtting 选择器 slow3G 可以对当前网络状态进行检测，查看接口的响应体积和顺序 npm run preview – –report 来分析 webpack 打包之后的各个静态资源的大小。你可以发现占用空间最多的是第三方依赖，前提是安装了包 webpack-bundle-analyzer 接口慢 因为这部分需要后端同事协助，所以在我发现存在一部分接口没有分页，前端数据量很大，记录下接口地址，然后开会和后端负责人讨论改造工作。（工作需要及时的安排和协调，让前后端同事工作并行，效率会比较高。 经接口调整后，接口整个速度都更上去了,页面卡顿有所缓解 减少 HTTP 请求升级 webpack 之前的项目结构 123yarn upgrade webpack@5.37.0yarn add webpack-dev-server webpack-cli -Dnpm-check-updates 一键升级所需的组件 由于各种考虑 vue 和 element-ui 没有升级 123456789// package.json\"scripts\": { - \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\", + \"dev\": \"npx webpack serve --config build/webpack.dev.conf.js --color --progress\", \"start\": \"npm run dev\", \"build\": \"node --max_old_space_size=2048 build/build.js\"}, webpack.base.conf.js 12- const merge = require('webpack-merge')+ const { merge } = require('webpack-merge') 新增 mode 选项 123module.exports = { + mode: process.env.NODE_ENV,} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117+ const VueLoaderPlugin = require('vue-loader/lib/plugin');... cacheGroups 对 chunks 的拆分起着关键的作用。可以通过 cacheGroups 来定制 chunks 拆分策略, 由于我们项目中存在很多插件，我们这里都把它单独拆分出来，配合cdn使用optimization: { splitChunks: { chunks: 'all', cacheGroups: { elementUI: { name: \"chunk-elementUI\", priority: 20, test: /[\\\\/]node_modules[\\\\/]element-ui[\\\\/]/ }, wangeditor: { name: \"chunk-wangeditor\", priority: 21, test: /[\\\\/]node_modules[\\\\/]wangeditor[\\\\/]/, }, vue: { name: \"chunk-vue\", priority: 20, test: /[\\\\/]node_modules[\\\\/]vue[\\\\/]/ }, moment: { name: \"chunk-moment\", priority: 15, test: /[\\\\/]node_modules[\\\\/]moment[\\\\/]/, }, lodash: { name: \"chunk-lodash\", priority: 15, test: /[\\\\/]node_modules[\\\\/]lodash[\\\\/]/, }, axios: { name: \"chunk-axios\", priority: 15, test: /[\\\\/]node_modules[\\\\/]axios[\\\\/]/, }, idValidator: { name: \"chunk-idValidator\", priority: 15, test: /[\\\\/]node_modules[\\\\/]id-validator[\\\\/]/, }, libs: { name: \"chunk-libs\", test: /[\\\\/]node_modules[\\\\/]/, minChunks: 4, priority: 10, reuseExistingChunk: true, }, common: { name: \"chunk-common\", test: resolve(\"src/components\"), // 可自定义拓展你的规则 minChunks: 4, // 最小共用次数 priority: 5, reuseExistingChunk: true } } }, runtimeChunk: { name: 'runtime' }},module: { rules: [ { test: /\\.vue$/, loader: 'vue-loader', options: vueLoaderConfig }, { test: /\\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test')], exclude: /node_modules/ }, { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]'), } }, { test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: utils.assetsPath('media/[name].[hash:7].[ext]') } }, { test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000000, // 注意到这里我设置的很大，因为字体文件太大，大概28k,也采取转换成base64，减少http请求 name: utils.assetsPath('fonts/[name].[hash:7].[ext]') } } ]},plugins: [ - new webpack.optimize.CommonsChunkPlugin('common.js'), + new VueLoaderPlugin(), - new webpack.optimize.CommonsChunkPlugin('common.js'), - new webpack.ProvidePlugin({ - jQuery: \"jquery\", - jquery: \"jquery\", - \"window.jQuery\":\"jQuery\", - $: \"jquery\" - }),],+ externals: require('./cdn').externals... webpack.dev.conf.js 新增 mode 选项 1234module.exports = { + mode: 'development', // 'production', 'development' or '无 (none)' + externals: require('./cdn').externals} webpack.prod.conf.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100- const ExtractTextPlugin = require('extract-text-webpack-plugin')+ const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")- const UglifyJsPlugin = require('uglifyjs-webpack-plugin') plugins: [// http://vuejs.github.io/vue-loader/en/workflow/production.htmlnew webpack.DefinePlugin({ 'process.env': env}),// new UglifyJsPlugin({// uglifyOptions: {// compress: {// warnings: false,// drop_debugger: true,// drop_console: true// }// },// sourceMap: config.build.productionSourceMap,// parallel: true// }),// extract css into its own filenew MiniCssExtractPlugin({ filename: utils.assetsPath('css/[name].[contenthash].css'), // Setting the following option to `false` will not extract CSS from codesplit chunks. // Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack. // It's currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it's `false`, // increasing file size: https://github.com/vuejs-templates/webpack/issues/1110 allChunks: true,}),// Compress extracted CSS. We are using this plugin so that possible// duplicated CSS from different components can be deduped.new OptimizeCSSPlugin({ cssProcessorOptions: config.build.productionSourceMap ? { safe: true, map: { inline: false } } : { safe: true }}),// generate dist index.html with correct asset hash for caching.// you can customize output by editing /index.html// see https://github.com/ampedandwired/html-webpack-pluginnew HtmlWebpackPlugin({ filename: config.build.index, template: 'index.html', inject: true, hash: version, minify: { removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true, // more options: // https://github.com/kangax/html-minifier#options-quick-reference }, cdn: require('./cdn').cdn, // necessary to consistently work with multiple chunks via CommonsChunkPlugin chunksSortMode: 'dependency'}),// keep module.id stable when vendor modules does not changenew webpack.HashedModuleIdsPlugin(),// enable scope hoistingnew webpack.optimize.ModuleConcatenationPlugin(),// split vendor js into its own file// new webpack.optimize.CommonsChunkPlugin({// name: 'vendor',// minChunks (module) {// // any required modules inside node_modules are extracted to vendor// return (// module.resource &amp;&amp;// /\\.js$/.test(module.resource) &amp;&amp;// module.resource.indexOf(// path.join(__dirname, '../node_modules')// ) === 0// )// }// }),// // extract webpack runtime and module manifest to its own file in order to// // prevent vendor hash from being updated whenever app bundle is updated// new webpack.optimize.CommonsChunkPlugin({// name: 'manifest',// minChunks: Infinity// }),// // This instance extracts shared chunks from code splitted chunks and bundles them// // in a separate chunk, similar to the vendor chunk// // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk// new webpack.optimize.CommonsChunkPlugin({// name: 'app',// async: 'vendor-async',// children: true,// minChunks: 3// }),// copy custom static assetsnew CopyWebpackPlugin([ { from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] }])] build/util.js 123456789101112131415161718192021222324252627282930const ExtractTextPlugin = require('extract-text-webpack-plugin')- const ExtractTextPlugin = require('extract-text-webpack-plugin')+ const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")function generateLoaders(loader, loaderOptions) { const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader] if (loader) { loaders.push({ loader: loader + '-loader', options: Object.assign({}, loaderOptions, { sourceMap: options.sourceMap }) }) } // Extract CSS when that option is specified // (which is the case during production build) if (options.extract) { return [MiniCssExtractPlugin.loader].concat(loaders) // return ExtractTextPlugin.extract({ // use: loaders, // publicPath: '../../', // fallback: 'vue-style-loader' // }) } else { return ['vue-style-loader'].concat(loaders) }} splitChunks 分离代码后，过大的插件被提取出来 合理使用缓存 静态图片和字体尽量缓存 cdn 123456789101112131415161718192021222324252627282930const isProduction = process.env.NODE_ENV === 'production';module.exports = { cdn: { css: [ 'https://unpkg.com/element-ui@2.15.9/lib/theme-chalk/descriptions.css', ], js: [ // \"https://unpkg.com/vue@2.6.10/dist/vue.min.js\", // \"https://unpkg.com/element-ui@2.15.7/lib/index.js\", 'https://unpkg.com/vuex@3.6.2/dist/vuex.min.js', 'https://unpkg.com/wangeditor@4.7.11/dist/wangEditor.min.js', 'https://unpkg.com/xlsx@0.15.6/dist/xlsx.full.min.js', 'https://unpkg.com/echarts@4.9.0/dist/echarts.min.js', 'https://map.qq.com/api/gljs?v=1.exp&amp;key=BSVBZ-5XSCX-EMQ4D-TIK2X-SIE2T-E6FQ5', // 'https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js', // 'https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/locale/zh-cn.min.js' ], }, externals: { // vue: \"Vue\", // \"element-ui\": \"ElementUI\", vuex: 'Vuex', wangeditor: 'wangEditor', XLSX: 'xlsx', echarts: 'echarts', TMap: 'TMap', // moment: \"moment\", },}; 找到 public/index.html。将 js 和 css 资源注入。 1234567891011121314151617&lt;head&gt; &lt;title&gt;${process.env.APP_ENV_NAME}&lt;/title&gt; &lt;!-- 引入样式 --&gt; &lt;% for(var css of htmlWebpackPlugin.options.cdn.css) { %&gt; &lt;link rel=\"stylesheet\" href=\"&lt;%=css%&gt;\"&gt; &lt;% } %&gt;&lt;/head&gt;&lt;body&gt; &lt;% for(var js of htmlWebpackPlugin.options.cdn.js) { %&gt; &lt;script src=\"&lt;%=js%&gt;\"&gt;&lt;/script&gt; &lt;% } %&gt; &lt;!-- built files will be auto injected --&gt; &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt; 文件压缩 - 图片压缩 免费的 web 端工具TinyPNG将 images 拖进去，替换掉你的图片，尺寸大幅度压缩并保证质量。 gzip 压缩 123456789101112131415if (config.build.productionGzip) { const CompressionWebpackPlugin = require('compression-webpack-plugin'); webpackConfig.plugins.push( new CompressionWebpackPlugin({ asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp( '\\\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 100, minRatio: 0.8, }) );} 折腾到这里，构建速度 40 左右，dist 压缩到 4M。首屏加载控制在 1s。效果显著！ 组件升级，支持虚拟加载 老项目中，使用 el-select，el-table 都不支持大数据虚拟加载，低版本存在卡顿现象 封装列表组件比较费时费力，版本 element-ui plus 支持虚拟加载。目前仅 keep-alive 来降低 dom 渲染消耗 推荐阅读 webpack 的黑历史 panjiachen 大佬对 cdn 的使用建议","link":"/2072f84bb4b4/"},{"title":"谈判力","text":"豆瓣地址 读后感简直不敢相信和《优势谈判》是同一作者，案例多次拿出来讨论，读起来没有任何新意，道理“很软”，无法打动我。大部分都在说如何把你的对手和你拉回谈判桌上，理智的进行下去。在我看来，在实际中没有什么帮助，会被对手碾压“温和派”谈判风格，我不认为可以有效用 谈判是从别人那里寻求自己所需的一个基本途径，是与谈判对方存在相同和不同利益时寻求解决方案的相互交流 原则谈判的原理是在道理、原则上强硬，对人则采取温和的态度。它不需要耍花招，不需要装腔作势。原则谈判让你得到想要的东西而又不失风度，它让你公平有理的同时又能保护自己不被对方利用 要在立场上讨价还价 在立场上纠缠不清不能达成明智的协议 如果双方就各自的立场讨价还价，他们通常会抱着立场不放。你越是声明自己的原则，保护自己的立场，你的立场就越坚定。你越想让对方明白改变你最初的立场是非分之想，你就会越死守自己的立场。直到把你的自我形象当成了你的立场。你现在又多了一个目标，就是保存自己的脸面—把今后的行为和过去的立场联系起来，这就使得谈判越来越不可能就双方的最初利益达成共识。 在立场上纠缠，缺乏效率 在立场上纠缠影响双方之间的关系 多方参与使立场式谈判更为不妙 友善不能解决问题 选择方案 以下四点几乎适用于任何场合每一点都围绕谈判的一个基本要素提出建议。 人：把人和事分开。 利益：着眼于利益，而不是立场。 选择：为共同利益创造选择方案。 标准：坚持使用客观标准。 每个谈判者都有两方面利益也就是：实质利益和关系利益 能站在对方的角度考虑问题，是谈判者应该掌握的最重要的技巧之一，尽管真正做到这一点并不容易。只认识到对方看问题的角度与我们的不同是不够的。如果想影响对方，则还需要切身理解对方观点的分量所在，感受对方深信不疑的观念中所包含的情感力量 讨论各自对问题的认识。消除认识分歧的一种办法是，亮出各自的想法，与对方进行讨论。只要做到态度坦率、诚恳，双方不从自己的角度出发指责对方，这样的讨论就能让双方怀着一份理解，认真倾听对方的真正意图。 采取象征性的姿态道歉是一项成本最小而收益最大的投资 着眼于利益，而不是立场 利益才是问题的关键 人和事分开 为共同利益创造选择方案 坚持使用客观标准 创造多种选择方案是谈判者可以拥有的最具价值的一笔财富。 在大多数谈判中，有四大障碍阻止了人们创造多种选择的方案： （1）不成熟的判断； （2）寻求单一的答案； （3）以为馅饼的大小是不变的； （4）认为“他们的问题应该由他们自己解决”。 为了克服这些障碍，你必须了解它们。 列一张清单。要理清谈判各方不同的利益，最好列一张清单，想到什么就写下来。这么做不仅能帮助你记住这些利益，而且当你获得新信息并把这些利益按重要性排序时，它有助于你提高评估质量。另外，这么做也许能启发你如何满足这些利益。 人们往往从心理上不愿承认对方观点的合理性；似乎想办法满足对方利益就是跟自己过不去。缺乏长远目光，只顾自己，导致谈判者只能形成片面的立场，片面的论据以及片面的解决方案。 关于共同利益，有三点值得牢记： 第一，共同利益潜藏在每项谈判中，它们往往不是即时可见的。 第二，共同利益只是机遇，不是天上掉下来的馅饼。要让它发挥作用，你必须对此有所作为。明确提出共同利益，并作为双方的共同目标，这将有助于谈判的进展。 第三，强调你们的共同利益可以使谈判变得愉快、顺利 融合不同利益：人们总是以为双方的差异会造成问题，却不知差异也能解决问题。 协议总是建立在分歧基础上。最利于双方达成协议的差异类型是利益差异、观念差异、不同的时间观、不同预期和对风险的不同态度等 不要再增加“谈判空间”—— 提供可吸引对方的选择项 尽量让对方的决定变得容易（感觉在瞎扯） 坚持使用客观标准独立于任何个人意愿—也就是根据客观标准来进行谈判。 原则谈判能愉快、有效地达成明智的协议。越是用公平原则、效率原则或科学标准解决具体问题，就越有可能最终达成明智而公平的一揽子协议 如果对方实力更强大怎么办当所有天平都倒向对方时，没有一种谈判模式能保证成功 面对强大的对手，最好的谈判结局不外乎实现下面两大目标： 第一是保护自己，不至于接受本应拒绝的协议； 第二是让你的谈判资源发挥最大效用，使达成的协议能尽量满足你的利益需求 制定你的最佳替代方案。积极寻找谈判破裂后自己所面临的选择，可以大大增强你的谈判实力。好的选择方案不会摆在那里等着你去拿，你必须自己去寻找。拿出最佳替代方案需要三个步骤： 第一，提出如果不能达成协议自己所要采取的措施； 第二，完善其中最有希望的想法，并把它们转化成具体的替代方案； 第三，初步选定看上去最好的替代方案 你越是能够轻松愉快地离开谈判桌，就越能左右谈判的结果。 如果对方不合作怎么办好比东方武术中的柔道和柔术一样，你避免与对方直接抗衡，运用躲闪技巧，借助对方的力量达到自己的目的。不要对抗对方的力量，相反，要把对方的力量引导到探讨双方利益、制定共同受益的选择方案和寻求客观标准上来。 不要攻击对方的立场，而是透过立场看利益 要替自己的想法辩护，欢迎批评和建议。谈判的大部分时间都花在相互指责上。与其拒绝对方的批评，不如对此持欢迎态度。我们不应要求对方接受或放弃某个观点，而应问对方这个观点是否有什么不妥。-&gt; 分析对方的否定态度，发现其中潜在的利益，并站在他们的角度改进自己的想法。根据你从对方了解的情况重新制定自己的方案，这样，批评就不再是谈判进程中的障碍，而成为达成协议必不可少的因素 把批评引向建设性轨道的另一种方法是，换位思考，征求对方的意见 提问与停顿。注重谈判柔术的人使用两个关键手段沉默是你最好的武器，要充分利用它。如果对方提出不合理方案或是采取在你看来站不住脚的攻击，最好的手段是一言不发。 沉默往往给人一种僵持不下的印象，对方为了打破僵局，不得不回答你的问题或者提出新的建议。因此在你提问之后，先停顿一下。不要急于提出新问题或发表自己的评论，给对方逃避尖锐问题的机会。有时，最有效的谈判是在你没有开口时发生的。 考虑使用独立调解程序独立调解程序作为一种机制，在限制决定数量、减少每个决定的不确定性以及防止谈判各方固守自己立场方面十分见效。独立调解程序对有第三方介入的双边谈判大有帮助，而对于多边谈判几乎是不可或缺的使用独立调解程序不必等到各方都同意。你只需要准备一份草案，然后征求各方的批评意见 乐于接受别人的指正和劝说，是原则谈判的战略支柱。只有乐于听取对方建议，才能说服对方以同样的态度接受你提出的原则和客观事实。 如果对方使用卑鄙手段怎么办人们可以运用种种手段和计谋占你的便宜。每个人都略知一二，例如谎言、心理攻击以及其他各种施压手段。这些手段是违法和不道德的，或者是让人感到不快的，其目的都是帮助使用者在非原则意志较量中“赢得”某些实际利益，我们称这种手段为诡计式谈判 当对方使用诡计时，商定谈判规则有三个步骤：发现诡计，揭穿诡计，质疑诡计的合理性与可取性—谈判就围绕这三步展开 不要为了教训对方而转移谈判的目的着眼于利益，而不是立场在互相让步之前，首先确定对方的权限。问一句：“你在谈判中有多大权力？”这是完全合理的 心理战术这种手段就是为了让你感觉不舒服，这样你潜意识里希望尽快结束谈判。环境压抑 如果发现周围环境对你不利，要立即指出来 人身攻击红白脸战术 红白脸战术是一种心理攻势，在打圆场的家伙说完之后回击威胁就是施压，施压的结果往往适得其反，它不但不解决问题，反而会带来压力。它不是帮助对方更容易作出决定，而是给对方增加难度 对方的威胁也可以变为你的政治优势 -&gt; 坚持原则也许是回应威胁的最好方式 立场上施压计策这种讨价还价的计策是营造某种声势，只使一方作出有效让步。 应对策略：首先，要认识到这一招是谈判的一种手段，目的是把同意谈判作为讨价还价的筹码，以获得实质上的让步。这一招的另一种形式是为谈判设置先决条件。接着，与对方谈谈他们拒绝谈判的理由。可以直接与对方交流或通过第三方进行沟通。不要因为对方拒绝谈判就抨击他们，而要找出对方拒绝谈判的利益所在然后，你可以提出一些选择方案最后，要坚持使用原则 锁定战术你可以用阻断对方传达信息的方式来应对强硬的破釜沉舟战术你也可以使用原则来抵制对方的锁定强硬的同伴。最常见的用来拒绝对方要求的谈判技巧是，谈判者本人称自己并不反对，但他的那位不好说话的同伴是不会答应的 故意拖延 不要成为牺牲品 关于本书，人们常问的10个问题","link":"/6a0f853a8be3/"},{"title":"迁移博客到阿里云","text":"之前在github pages上部署了博客，后来发现百度不收录，挣扎下，购入一台阿里云的云服务器liunx，一键部署到github和阿里云上，国内外都能访问，这样就好很多了。 这样我们在本地编写好文章，hexo clean &amp;&amp; hexo d 后,部署Hexo帮我们生成静态的html页面，并通过Hexo将生成的html文件上传到我们的阿里云服务器。 相关阅读： 如何零成本搭建一个博客如何同步并管理我的文章 本地访问服务器服务器配置 Mobaxterm软件下载：https://mobaxterm.mobatek.net/ 填写外网地址，用户root和密码 环境搭建安装nginx，git12yum install nginxyum install git 测试是否安装成功：出现 Ngnix 相关版本信息，则表明成功。 12[root@iZbp17a3lpyn5dsm8xnv7rZ ~]# nginx -vnginx version: nginx/1.22.1 可以查看下 nginx 相关的目录： /usr/sbin/nginx: nginx 主程序 /etc/nginx: 存放 nginx 相关配置 /var/log/nginx: 存放 nginx 日志 我们来到 ect/nginx文件夹下，选中nginx.conf右击选择第二个[open with default text editor]打开默认文本编辑。 配置nginx123456789server { listen 80; server_name [你的域名]; location / { root /root/my-blog/public/; // 这里是我的博客存放路径，记得换成你的 index index.html; }} 我们要通过80端口访问nginx服务，、添加安全组阿里云工作台：点击云服务器/ECS安全组-配置规则-添加安全规则 启动nginx 1service nginx reload 这个时候你可以在你的静态目录下创建一个html，通过外网ip来检测是否配置成功了。 自动化部署创建git用户123adduser gitchmod 740 /etc/sudoersvim /etc/sudoers 按i键由命令模式切换到编辑模式，:wq保存退出 12root ALL=(ALL) ALL+ git ALL=(ALL) ALL 1234567sudo passwd git // 需要root权限设置Git用户的密码su gitmkdir ~/.sshvim ~/.ssh/authorized_keys#然后将电脑中执行 cat ~/.ssh/id_rsa.pub ,将公钥复制粘贴到authorized_keyschmod 600 ~/.ssh/authorzied_keyschmod 700 ~/.ssh 在本地打开终端： 1ssh -v git@SERVER 可以看是否能访问了。 服务器git配置123cd /home/gitgit init --bare hexo.gitchown -R git:git hexo.git //修改权限 在 /home/git/hexo.git/hooks/post-receive 文件中写入： 12#!/bin/shgit --work-tree=/root/my-blog/public --git-dir=/home/git/hexo.git checkout -f 1chmod +x post-receive //修改权限 至此，我们可以在本地 git clone git@SERVER 克隆下来文件了。 hexo配置根目录config.yml文件 1234567deploy:- type: 'git' repo: git@120.27.234.107:/home/git/hexo.git branch: 'master'- type: 'git' repo: https://github.com/xuxia2013/xuxia2013.github.io.git branch: 'main' 测试是否能部署到阿里云上： 1hexo d 成功！","link":"/02d5b1c6e6af/"},{"title":"JavaScript后端框架：Next, Nest, Nuxt… Nust?","text":"原文：https://www.twilio.com/blog/comparing-nextjs-nestjs-nuxt-gatsby作者：Marius Obert 如果你正在寻找合适的 JavaScript 后端框架，并且面对 Gatsby、Next.js、Nest 和 Nust 等框架不知道如何选择的话，那么不妨进来看看吧。 下面将分析这些框架的异同，它们的性能特点，受欢迎程度，希望能够帮助你选择最适合你的框架。 根据最新的 JavaScript 状态调查，所有这些开源框架都是最受欢迎的后端框架。JS 状态调查显示，Next.js、Gatsby、Nuxt 和 Nest 位列前五。它们排在不败的第一名 Express 的后面，并且还在不断增长。如下图 Express 几乎从 Node.js 诞生之初就已经存在，是事实上的标准 JavaScript 框架，它经常被称作许多其他框架的基础。 Gatsby介绍⭐️ 54.1K Gatsby 最初在 2015 年被构想为 React Web 应用的静态网站生成框架。Gatsby 主要的应用的技术是 React 和 GraphQL，利用 Gatsby 搭建一个简单的静态站点。已被 Netlify 收购 GitHub：https://github.com/gatsbyjs/gatsby官网：https://www.gatsbyjs.cn/ 特点 支持各种数据源： headless CMSs, SaaS services, APIs, databases,your file system……通过 Graphql 更直接的获取数据。 丰富的生态系统，庞大的插件库 可以灵活地放在最适合您的托管平台：Netlify、Firebase、Azure、AWS、Vercel 或您想要的任何平台 支持 cdn 该框架不支持自定义后端逻辑 Gatsby 最适合个人博客和较小的静态站点，比如公司网站 demo一个 404 页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import * as React from 'react';import { Link } from 'gatsby';import { StaticImage } from 'gatsby-plugin-image';const pageStyles = { color: '#232129', padding: '96px', fontFamily: '-apple-system, Roboto, sans-serif, serif',};const headingStyles = { marginTop: 0, marginBottom: 64, maxWidth: 320,};const paragraphStyles = { marginBottom: 48,};const codeStyles = { color: '#8A6534', padding: 4, backgroundColor: '#FFF4DB', fontSize: '1.25rem', borderRadius: 4,};const NotFoundPage = () =&gt; { return ( &lt;main style={pageStyles}&gt; &lt;h1 style={headingStyles}&gt;Page not found&lt;/h1&gt; &lt;StaticImage alt=\"Clifford, a reddish-brown pitbull\" src=\"https://pbs.twimg.com/media/E1oMV3QVgAIr1NT?format=jpg&amp;name=large\" /&gt; &lt;p style={paragraphStyles}&gt; Sorry 😔, we couldn't find what you were looking for. &lt;br /&gt; {process.env.NODE_ENV === 'development' ? ( &lt;&gt; &lt;br /&gt; Try creating a page in &lt;code style={codeStyles}&gt;src/pages/&lt;/code&gt;. &lt;br /&gt; &lt;/&gt; ) : null} &lt;br /&gt; &lt;Link to=\"/\"&gt;Go home&lt;/Link&gt;. &lt;/p&gt; &lt;/main&gt; );};export default NotFoundPage; Next.js介绍⭐️ 101K Next.js 框架最初于 2016 年发布，Next.js 是一个 React 应用框架。 GitHub：https://github.com/vercel/next.js官网：https://www.nextjs.cn/ Next 的 CLI 工具 create-next-app 与 create-react-app 的工作方式相同，允许你启动一个完整的应用程序，其中内置包括图像优化和页面路由等附加功能。Next 是轻量级和易于使用的，可供业余爱好者使用，但也足够强大，可以扩展以供企业使用。Netflix、Hulu、耐克等每天网站访问量达数万人次的大型企业都在使用 Vercel 托管的 Next 应用程序。非常适合有大量更新的网站、大型企业级应用程序。 特点 Next.js 支持静态站点生成、服务器端渲染、增量静态重新生成和客户端数据获取。 Next.js 的一个独特之处在于其巨大的知名度、庞大的社区和广泛的使用。 允许您将其托管在自己的基础设施上 该框架中没有状态的概念；需要手动添加一个数据库来存储状态。 demo首页页面 123456789101112131415161718192021222324252627282930313233343536373839import Head from 'next/head';import Image from 'next/image';import styles from '../styles/Home.module.css';export default function Home() { return ( &lt;div className={styles.container}&gt; &lt;Head&gt; &lt;title&gt;Create Next App&lt;/title&gt; &lt;meta name=\"description\" content=\"Generated by create next app\" /&gt; &lt;link rel=\"icon\" href=\"/favicon.ico\" /&gt; &lt;/Head&gt; &lt;main className={styles.main}&gt; &lt;h1 className={styles.title}&gt; Welcome to &lt;a href=\"https://nextjs.org\"&gt;Next.js!&lt;/a&gt; &lt;/h1&gt; &lt;p className={styles.description}&gt; Get started by editing{' '} &lt;code className={styles.code}&gt;pages/index.js&lt;/code&gt; &lt;/p&gt; &lt;/main&gt; &lt;footer className={styles.footer}&gt; &lt;a href=\"https://vercel.com?utm_source=create-next-app&amp;utm_medium=default-template&amp;utm_campaign=create-next-app\" target=\"_blank\" rel=\"noopener noreferrer\" &gt; Powered by{' '} &lt;span className={styles.logo}&gt; &lt;Image src=\"/vercel.svg\" alt=\"Vercel Logo\" width={72} height={16} /&gt; &lt;/span&gt; &lt;/a&gt; &lt;/footer&gt; &lt;/div&gt; );} NuxtJS介绍⭐️ 43.6K NuxtJS 最初发布于 2016 年，在多个方面与之前的框架不同。最明显的区别是，你不是用 React 构建，而是在另一个流行的 UI 框架上：Vue.js。但这并不意味着 Nuxt 是 Next.js 的一个移植。Nuxt 在概念上非常不同，它提供所有的渲染选项–甚至是客户端渲染。所以这个框架也可以用于渐进式 Web 应用。 GitHub：https://github.com/vercel/next.js官网：https://www.nuxtjs.cn/ 除此之外，它还带有一个丰富的开发文档，如何添加配置、测试框架、构建框架和组件包等。Nuxt 还带有状态存储功能：Vuex Store。 demo定义一个页面 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;h1&gt;Hello Nuxters! 👋&lt;/h1&gt; &lt;p&gt; This page is rendered on the &lt;strong&gt;{{ rendering }}&lt;/strong&gt; &lt;/p&gt; &lt;p v-if=\"rendering === 'server'\"&gt; First load or hard refresh is done on server side. &lt;/p&gt; &lt;p v-if=\"rendering === 'client'\"&gt;Navigation is done on client side.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Refresh the page for server side rendering.&lt;/li&gt; &lt;li&gt;Click the links to see client side rendering.&lt;/li&gt; &lt;/ul&gt; &lt;NuxtLink to=\"/about\"&gt;About Page&lt;/NuxtLink&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { asyncData() { return { rendering: process.server ? 'server' : 'client' } }}&lt;/script&gt; ps: 有一个很好的记忆技巧来区分这些听起来相似的框架。Next.js 使用 React，Nuxt 使用 Vue.js。 Nest介绍⭐️ 54.4K Nest 是 2018 年推出的,受 Angular 启发的框架，也是这个系列中真正的异类。虽然其他框架都实现了各种渲染策略，但 Nest 旨在成为一个与平台无关的框架。这个用于服务器端应用程序的框架更类似于著名的 Spring 框架，可用于实现微服务。它通过对象关系映射器和许多额外的协议，如 WebSockets、GraphQL 和 MQTT，支持几乎所有流行的数据库管理系统。 Nest 使用 Express，但也提供了与其他广泛的库的兼容性，例如，Fastify，允许方便地使用第三方插件。 GitHub：https://github.com/nestjs/nest官网：https://www.nestjs.com.cn/ 特点 有更高的服务器负载，并且可能更难扩展 对于一部分后端工程师来说，学习成本低些 demo1234567891011import { Module } from '@nestjs/common';import { AppController } from './app.controller';import { AppService } from './app.service';import { ConfigModule } from '@nestjs/config';@Module({ imports: [ConfigModule.forRoot()], controllers: [AppController], providers: [AppService],})export class AppModule {} 分析下面是npm的下载数字以及GitHub和Stack Overflow的一些社区统计。 这些数据截至2022年12月。 在几乎所有这些指标中，我们都能看到 Next.js 的领先地位。它拥有最多的下载量、GitHub 星级和分叉，以及 Stack Overflow 上最广泛的知识库。令人惊讶的是，Gatsby 拥有最多的 GitHub 贡献，这表明其丰富的生态系统有多大。起初，与 Gatsby 和 Nuxt 相比，Nest 的周下载量如此之多也令人惊讶，即使其他统计数字非常相似。一个可能的解释是，Nest 是唯一列出的可用于实现后端服务器的框架，因此，没有竞争。即使其他框架不能自由互换，它们都可以用于服务器渲染的 HTML 页面，并可能在某种程度上自食其果。 如何选择适合自己的框架让我们重新审视一下这篇文章的开头。如何选择最适合你的框架？要回答这个问题，你需要问自己以下几个问题： 你到底想不想建立一个全栈式的应用程序？ 如果是的话，你是想要更多的自由和灵活性，还是更喜欢开箱即用的模块，如果一开始就有的话，你可以插入哪些模块来获得想要的结果？ 如果应用程序不需要全栈开发，根据你对性能和SEO友好性的需求，你更喜欢哪种渲染策略？ 下面的决策树可能对你有点帮助~ 我的建议如果你想学习新东西，我建议你去看看Next.js。如果你想建立一个利用React的网站，并且具有信息性，没有大量的交互性，如公司网站、博客或产品的登陆页面，它是非常好的。如果你想建立这样的网站，但更喜欢Vue.js，那么选择Nuxt。 如果符合你的需求，用React或Vue.js建立一个SPA，没有后端框架也是可以的。另一方面，当你想建立一个服务器应用程序时，评估一下你是否想用提供即插即用机制的成熟模块（Nest）来建立，或者你是否想用Express来自己开发一切。","link":"/045a82182849/"},{"title":"Uniapp如何实现持续定位，全程录音功能","text":"持续定位和全程录音都需要息屏运行，切后台运行的应用保活。说到保活，这里博大精深。就不展开说了，本着对用户负责的态度开发一款好产品，在用户允许的前提下，提高用户体验。这里介绍启动前台 Service 的技巧。 添加本地插件在根目录下创建文件夹【nativeplugins】，把 https://github.com/jeawy/UniPlugin-Hello-AS 中 zjw-frontservice 文件夹放进去。 manifest.json 点开，选择本地插件，把此插件添加进去 制作自定义基座编辑器中选中：运行 -&gt; 选择【运行到安卓模拟机】-&gt; 选择【制作自定义调试基座】 运行到真机 其他可操作的功能：退出时，友好的提示用户，离开此应用的话，会导致服务中断，可以提供选择到后台运行的选项 main.js 12345678910111213141516171819202122// #ifdef APP-PLUS&lt;view class=\"modal-footer\"&gt; &lt;text&gt;有任务在进行中，是否退出？ &lt;/text&gt;&lt;/view&gt;&lt;view class=\"modal-footer\"&gt; &lt;text @click.stop=\"confirm\"&gt;后台运行&lt;/text&gt; &lt;text @click.stop=\"cancel\"&gt;取消&lt;/text&gt; &lt;text @click.stop=\"exit\"&gt;退出&lt;/text&gt;&lt;/view&gt;// methodsconfirm(){ let main = plus.android.runtimeMainActivity() main.moveTaskToBack(false);}exit(){ plus.runtime.quit();}cancel{ // 模态框消失}// #endif 开发代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;script&gt;const frontservice = uni.requireNativePlugin('zjw-frontservice');const recorderManager = uni.getRecorderManager();const innerAudioContext = uni.createInnerAudioContext();innerAudioContext.autoplay = true;export default { data() { return { voicePath: '', }; }, onLoad() { let self = this; recorderManager.onStop(function (res) { console.log('recorder stop' + JSON.stringify(res)); self.voicePath = res.tempFilePath; }); }, methods: { stop() { frontservice.stop({}, (result) =&gt; { modal.toast({ message: 'closed', duration: 1.5, }); }); }, start() { frontservice.start( { title: '请不要关闭此固定通知栏', content: '正在定位...', delaysec: 2000, isIgnoringBattery: false, //不开启电池优化 }, (result) =&gt; { console.log(result); // 录音代码 this.startRecord(); } ); }, startRecord() { // 授权录音权限 let env = uni.getSystemInfoSync().platform; permision .requestAndroidPermission('android.permission.RECORD_AUDIO') .then((e) =&gt; { if (e === -1) { uni.showToast({ title: '您已经永久拒绝录音权限，请在应用设置中手动打开', icon: 'none', }); } else if (e === 0) { uni.showToast({ title: '您拒绝了录音授权', icon: 'none', }); } else if (e === 1) { this.show = true; console.log('开始录音'); recorderManager.start(); console.log('开始定位'); uni.getLocation({ type: 'wgs84', success: function (res) { console.log('当前位置的经度：' + res.longitude); console.log('当前位置的纬度：' + res.latitude); } }); } else { uni.showToast({ title: '授权返回值错误', icon: 'none', }); } }) .catch((err) =&gt; { uni.showToast({ title: '拉起录音授权失败', icon: 'none', }); }); }, // 上传录音文件 uploadRecord() { uni.showLoading(); uni.uploadFile({ url, '地址', filePath: this.voicePath, //录音结束后返回的临时路径 name: 'file', // 文件对应的 key值对象名称 header: { 'Content-Type': 'multipart/form-data', token: 'token', //token信息 }, success: (res) =&gt; { uni.hideLoading(); console.log('result', result); }, fail: (res) =&gt; { uni.hideLoading(); uni.showToast({ title: '失败', icon: 'none', }); }, }); }, },};&lt;/script&gt; 其他阅读 Android 进程保活（如何尽可能避免 APP 被杀死）","link":"/806c829afb4d/"},{"title":"uniapp中接入融云-IM 云服务","text":"如何选择 IM 云服务供应商？主要看这三个因素：价格、核心服务稳定、技术资料及时的客服咨询。之前集成过anyrtc，大家可以翻翻之前记录，主要是音视频通话服务，我发现，市场上众多的 IM 云服务，anyrtc 和融云 技术实现上很相似，视频通话服务技术对接也简单, 从长远看，收费服务意味着很大的风险，稳定好服务, 满足预期才能深入人心。 注册账户首先前往官网注册：https://developer.rongcloud.cn/signup#?_sasdk=fMjUzMDkz 登陆成功后会有一个已经设置好的 appkey, 左侧菜单拉到最下方 【音视频通话】开启免费额度1万分钟，uniapp打包后一直使用这个开发appkey也是有1万分钟的额度。 项目配置 云端插件 融云实时音视频 SDK uni 原生插件：https://ext.dcloud.net.cn/plugin?id=6372融云即时通讯 SDK uni 原生插件 V2：https://ext.dcloud.net.cn/plugin?id=9227融云基础版美颜插件，服务于 RCUniRtc 或 RCUniRtc：https://ext.dcloud.net.cn/plugin?id=7982 选择中你的姓名包 key 0 元购入 本地插件 融云 IM 原生插件包装层 RongCloud-IMWrapper-V2：https://ext.dcloud.net.cn/plugin?id=9225RongCloud-CallWrapper：https://ext.dcloud.net.cn/plugin?id=7136RongCloud-BeautyWrapper：https://ext.dcloud.net.cn/plugin?id=7985 直接通过 HBuilder X 导入项目中。 完成后 项目开发 app.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import * as call from \"@/uni_modules/RongCloud-CallWrapper/lib/index\";import RCIMIWEngine from \"@/uni_modules/RongCloud-IMWrapper-V2/js_sdk/RCIMEngine\";import permision from \"@/js_sdk/wa-permission/permission.js\";// 应用唤醒后开始注册、连接imonLaunch: function () { // #ifdef APP-PLUS this.init(); // 监听用户登录后回调 uni.$on(\"loginSuccess\", (usnerinfo) =&gt; { this.connectIM(usnerinfo); }); // #endif},methods:{ init() { call.onCallReceived((res) =&gt; { console.log( \"Engine:OnCallReceived=&gt;\" + \"监听通话呼入, 目标id=&gt;\", res.data.targetId ); // 接收到邀请呼叫 跳转呼叫页面 uni.navigateTo({ url: \"/pages/room/call\" + \"?id=\" + res.data.targetId, }); this.localSession = res.data; }); call.onCallDisconnected((res) =&gt; { console.log( \"Engine:OnCallDisconnected=&gt;\" + \"通话挂断/拒绝, 挂断原因=&gt;\", res.data.reason ); uni.navigateBack({ delta: 1, }); // 重新渲染视频视图 uni.$emit(\"OnCallDisconnected\"); }); call.onError((res) =&gt; { console.log(\"通话过程中，发生异常\"); }); call.onRemoteUserInvited((res) =&gt; { console.log( \"Engine:OnRemoteUserInvited=&gt;\" + \"通话中的某一个参与者，邀请好友加入通话 ,远端Id为=&gt;\", res.data.userId ); uni.$emit(\"OnCallConnected\"); }); call.onRemoteUserJoined((res) =&gt; { console.log( \"Engine:OnRemoteUserJoined=&gt;\" + \"主叫端拨出电话，被叫端收到请求后，加入通话，对端Id为=&gt;\", res.data.userId ); uni.$emit(\"OnCallConnected\"); }); }, //连接IM async connectIM(userInfo) { if (!userInfo.appKey || !userInfo.token) return; this.imEngine = await RCIMIWEngine.create(userInfo.appKey, {}); this.imEngine.setOnConnectedListener((res) =&gt; { if (res.code != 0) { return; } //连接成功 call.init({}); if (uni.getSystemInfoSync().platform === \"android\") { permision.requestAndroidPermission(\"android.permission.CAMERA\"); permision.requestAndroidPermission(\"android.permission.RECORD_AUDIO\"); } }); let code = await this.imEngine.connect(userInfo.token, 10); if (code != 0) { uni.showToast({ title: \"connect:\" + code, icon: \"error\", }); } else { uni.showToast({ title: \"连接IM成功\", icon: \"none\", duration: 2000, }); } },} pages.json 1234567891011121314151617181920212223{ \"path\" : \"pages/room/call\", \"style\" : { \"navigationBarTitleText\": \"呼叫\", \"enablePullDownRefresh\": false, \"navigationStyle\":\"custom\", \"gestureBack\":\"NO\", \"app-plus\" : { \"background\":\"white\" } }},{ \"path\" : \"pages/room/room\", \"style\" : { \"navigationBarTitleText\": \"Room\", \"enablePullDownRefresh\": false, \"navigationStyle\":\"custom\", \"gestureBack\":\"NO\" }}, call.nvue 呼叫页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;view class=\"content\"&gt; &lt;view class=\"logo\"&gt; &lt;image class=\"logo-img\" src=\"../../static/icon-ch.png\" mode=\"\"&gt;&lt;/image&gt; &lt;text class=\"name\"&gt;{{ id }} &lt;/text&gt; &lt;/view&gt; &lt;view class=\"container\"&gt; &lt;view class=\"icon\" @click=\"hangup\"&gt; &lt;image class=\"icon_img\" src=\"../../static/icon_hangup.png\" mode=\"\" &gt;&lt;/image&gt; &lt;text class=\"icon_text\"&gt;挂断 &lt;/text&gt; &lt;/view&gt; &lt;view class=\"icon\" @click=\"accept\"&gt; &lt;image class=\"icon_img\" src=\"../../static/icon_accept.png\" mode=\"\" &gt;&lt;/image&gt; &lt;text class=\"icon_text\"&gt;接听 &lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import * as call from \"@/uni_modules/RongCloud-CallWrapper/lib/index\"; import RCBeautyEngine from \"@/uni_modules/RongCloud-BeautyWrapper/lib/RCBeautyEngine\"; export default { data() { return { id: \"\", }; }, onLoad: function (option) { this.id = option.id; }, methods: { hangup() { call.hangup(); uni.navigateBack({ delta: 1, }); }, accept() { let session = call.getCurrentCallSession(); console.log('session: ', session); uni.setStorageSync('room-parameters', { callType: 'in', mediaType: session.mediaType === 0 ? 'audio' : 'video' }); // 接受呼叫后跳转聊天页面 uni.navigateTo({ url: \"/pages/room/room\", }); }, }, };&lt;/script&gt; room.nvue 聊天页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&lt;template&gt; &lt;view class=\"content\"&gt; &lt;!-- 单人视频 --&gt; &lt;view&gt; &lt;RongCloud-Call-RCUniCallView class=\"bigVideoView\" :style=\"{ width: windowWidth + 'px', height: windowHeight + 'px' }\" ref=\"bigVideoView\" &gt; &lt;/RongCloud-Call-RCUniCallView&gt; &lt;RongCloud-Call-RCUniCallView class=\"smallVideoView\" :style=\"{ width: 200 + 'upx', height: 200 + 'upx' }\" ref=\"smallVideoView\" &gt; &lt;/RongCloud-Call-RCUniCallView&gt; &lt;/view&gt; &lt;view class=\"container\"&gt; &lt;text class=\"hangup\" @click=\"hangup\"&gt;挂断&lt;/text&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import * as call from \"@/uni_modules/RongCloud-CallWrapper/lib/index\"; import RCBeautyEngine from \"@/uni_modules/RongCloud-BeautyWrapper/lib/RCBeautyEngine\"; export default { data() { return { mediaType: \"video\", callType: \"out\", callWay: 0, //呼叫方式 0 单聊 1 群聊 targetId: \"\", isConnected: false, isSelf: false, viewArr: [], groupId: \"\", userIds: [], windowWidth: \"\", windowHeight: \"\", users: [], currentCallSession: {}, }; }, onLoad: function () { var _this = this; uni.getStorage({ key: \"room-parameters\", success: (res) =&gt; { this.mediaType = res.data.mediaType; this.callType = res.data.callType ? res.data.callType : \"in\"; this.groupId = res.data.groupId ? res.data.groupId : \"\"; this.userIds = res.data.userIds ? res.data.userIds : \"\"; if (this.callType === \"in\") { console.log(\"呼入接受\"); this.accept(); } }, }); uni.getSystemInfo({ success: function (res) { _this.windowWidth = res.windowWidth; _this.windowHeight = res.windowHeight; }, }); uni.$on(\"OnCallConnected\", this.onCallConnected); uni.$on(\"OnCallDisconnected\", this.onCallDisconnected); }, beforeDestroy() { uni.$off(\"OnCallDisconnected\"); uni.$off(\"OnCallConnected\"); }, onUnload() { // call.hangup(); }, onHide() { // const session = call.getCurrentCallSession(); // if (session) { // call.hangup(); // } }, methods: { hangup() { this.isSelf = true; call.hangup(); uni.navigateBack({ delta: 1, }); }, accept() { call.accept(); }, onCallConnected() { let context = this; console.log(\"oncallconnected接收了\"); call.enableSpeaker(true); this.currentCallSession = call.getCurrentCallSession(); this.callWay = this.currentCallSession.callType; this.users = this.currentCallSession.users ? this.currentCallSession.users : []; let isHasMine = this.users.findIndex((item) =&gt; { return item.userId === this.currentCallSession.mine.userId; }); if (isHasMine === -1) { this.users.push(this.currentCallSession.mine); } if ( this.currentCallSession &amp;&amp; this.currentCallSession.users.length &gt; 0 ) { //视频是两个的时候 if (this.currentCallSession.users.length &lt;= 2) { setTimeout(() =&gt; { this.systemInfoSync( this.currentCallSession.mine.userId, this.$refs.smallVideoView.ref, true ); this.viewArr = this.currentCallSession.users.filter((item) =&gt; { return item.userId !== this.currentCallSession.mine.userId; }); this.viewArr.forEach((itm) =&gt; { this.targetId = itm.userId; this.systemInfoSync( itm.userId, this.$refs.bigVideoView.ref, false ); }); }, 100); } } }, systemInfoSync(userId, ref, isZOrderOnTop) { switch (uni.getSystemInfoSync().platform) { case \"android\": call.setVideoView(userId, ref, 0, isZOrderOnTop); break; case \"ios\": call.setVideoView(userId, ref, 0); break; default: console.log(\"运行在开发者工具上\"); break; } }, onCallDisconnected() { if (!this.isSelf) { uni.navigateBack({ delta: 1, }); } }, }, };&lt;/script&gt; 结果 融云特点 上手友好 收费高 技术咨询 提交工单几乎是 1个小时网页回复","link":"/6d2ad211fa52/"},{"title":"前端初学者如何接入ChatGPT","text":"AI 研究实验室 OpenAI 创建了一个强大的 API，允许开发人员利用尖端的 AI 功能并使用 GPT3 等生成语言模型。在本教程中，我们将向您展示如何将 OpenAI API 与 Axios 和 JavaScript 结合使用，让您瞥见由 AI 驱动的 Web 开发的未来。 Axios 是一个流行的 JavaScript 库，用于发出 HTTP 请求并与 API 集成，使其成为访问 OpenAI API 的完美工具。无论您是经验丰富的开发人员还是刚刚起步，希望本文能对你有帮助 ~ 您可以在以下网址找到有关 Axios 库的更多信息 Github: https://github.com/axios/axios 官网: https://axios-http.com/ 第一步：获取OpenAI API密钥 要获取 OpenAI API 的 API 密钥，您需要在 OpenAI 网站 ( https://openai.com/ )上注册一个免费的 OpenAI 帐户：如果你不会注册用户，这里有份非常详细指南： https://github.com/hardwellwell/FreePAC/wiki/ChatGPT%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B%EF%BC%88%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97%EF%BC%89 注册成功后，登录 https://platform.openai.com/ 在“API”部分，您会找到一个标有“生成 API 密钥”的按钮。单击此按钮可生成一个新的 API 密钥，然后您可以使用该密钥从您的 Web 应用程序向 OpenAI API 发出请求。 第二步：设置项目新建项目 创建一个新的项目文件夹来设置 JavaScript 项目 12$ mkdir openai-axios $ cd openai-axios 在该新项目文件夹中，使用 Node.js 包管理器 (NPM) 创建一个新的初始 package.json 文件。这是先决条件，以便我们能够使用 NPM 安装更多依赖项： 1$ npm init -y 运行此命令时，您应该能够在控制台上看到写入 package.json 的内容： 接下来，使用 NPM 安装包dotenv和axios。 1$ npm install dotenv axios 完整代码这个是完整代码： // index.js 123456789101112131415161718192021222324252627const axios = require(\"axios\");require(\"dotenv\").config();const apiKey = [OPENAI_API_KEY]; // 你的keyconst client = axios.create({ headers: { Authorization: \"Bearer \" + apiKey, },});const params = { prompt: \"How are you?\", model: \"text-davinci-003\", max_tokens: 10, temperature: 0,};client .post(\"https://api.openai.com/v1/completions\", params) .then((result) =&gt; { console.log(result.data.choices[0].text); }) .catch((err) =&gt; { console.log(err); }); 使用 Promise 方法处理对请求的响应.then()，该方法在请求成功时调用。API 返回的对象与响应数据数组result中第一个选择的文本一起记录到控制台。 运行 node index.js 结果","link":"/25633ba1e544/"},{"title":"学习资料：Rust-未来前端基础设施","text":"Rust现在仍然算是比较小众的语言，不过近几年发展速度非常快，生态版图也挺大的，被称作是Web3.0的语言，具体可以看看【上篇】2021 年 Rust 生态版图调研报告 | 星辰大海 和【下篇】2021 年 Rust 生态版图调研报告 | 星辰大海 ———— 来自知乎：不咸​ https://www.zhihu.com/question/31038569 作为新兴的开发语言，Rust不仅在函数式编程、网络编程、多线程、消息同步、锁、测试代码、异常处理等方面都有不错的表现，对比Javascript,rust有更灵活的内存管理等。 Rust是一种可以进行底层开发的高级语言，现在流行的开发语言很多，但能够进行操作系统底层开发的选择项并没有几个。作为前端er, 转全栈的话，值得学习。 Rust 让你思考你的代码的方方面面，这对于系统开发是极为重要的。Rust 强制你思考内存是如何共享和拷贝的。Rust 强制你思考少见但是真实的边缘场景，以确保这些边缘场景也被控制住了。在任何能提升你效率的地方，Rust 都会帮你。 ———— Tom MacWright https://macwright.com/2021/01/15/rust.html 下面是我整理的一些学习资料，我也在学。迎难而上，才能有所不争 学习资料整理 Rust语言圣经(Rust Course) https://course.rs/about-book.html Rust 程序设计语言 https://kaisery.github.io/trpl-zh-cn/ 英文版本：https://doc.rust-lang.org/nightly/book/ learn-rust-for-fe https://github.com/i5ting/learn-rust-for-fe Rust Is The Future of JavaScript Infrastructure https://leerob.io/blog/rust 边学边练 https://www.rust-lang.org/zh-CN/learn/get-started 附上： 【上篇】2021 年 Rust 生态版图调研报告 | 星辰大海 https://zhuanlan.zhihu.com/p/456451233 【下篇】2021 年 Rust 生态版图调研报告 | 星辰大海 https://zhuanlan.zhihu.com/p/458046979","link":"/0a8b6d1c1e48/"},{"title":"在GitHub上学习系列之AI课程","text":"火爆了的ChatGPT，兴奋劲过去了之后谈谈我的一些看法 很多人说会替代程序员，且不说程序员每天能敲多少代码，大量时间都在跟产品撕逼，写文档，真正写代码时间是很少的，其次，我乐观看未来20年应该还不能替代程序员，程序员这工作还没有那么大的风险。不过，对于这样提高效率的工具，大家应该学习然后用起来，省了很多脑细胞不是嘛？后台很多小伙伴问怎么学习ai技术，下面提供些吧，或许你有更好的教程，也请发出来看看，ai对一般人是遥不可及的，学习路线漫漫长，技术的魅力就在每一次深入研究后发掘中，顿悟后那点点自豪感吧。 1. microsoft/AI-For-Beginners ⭐️ 5.2K Github: https://github.com/microsoft/AI-For-Beginnershttps://microsoft.github.io/AI-For-Beginners/ 2.microsoft/ML-For-Beginners 初学者机器学习 ⭐️ 44.9K Github: https://github.com/microsoft/ML-For-Beginnershttps://microsoft.github.io/ML-For-Beginners/#/ 3.microsoft/ai-edu 中文教程 面向中国学生、教师和 IT 专业人员的 AI 教育课程。 ⭐️ 11.6K Github: https://github.com/microsoft/ai-eduhttps://microsoft.github.io/ai-edu/","link":"/392cbd981ca7/"},{"title":"自建图床","text":"自用的轻量 web 端图床 https://admin.noraxu.online/open/upload 特色 图片高质量压缩 支持第三方云储存阿里云 OSS 多图上传、拖拽上传、一键复制图片外链 二维码手机扫描查看，下载 无需登录，无密码，随用随走 永久保存","link":"/2cea3fa6c2b4/"},{"title":"推荐一个免费好用的下载技术书籍的网站","text":"https://freecomputerbooks.com/","link":"/e19032dae9bc/"},{"title":"浅谈低代码","text":"2019那年，疫情来势汹汹，席卷一切。从火爆出圈的 Disco Diffusion 到 ChatGPT，大家对新技术仍然充满了期待，正如逍遥子在9月份的云栖大会上说的“新技术代表的新生产力，一定是我们全速战胜疫情、开创未来最好的原动力。” 那么究竟需要什么样的新技术，才能真正解放IT生产力，加速社会数字化转型呢？ 我并不认为是低代码（Low-Code）… 什么是低代码低代码开发平台是一种用于构建具有图形用户界面的应用程序的应用开发软件。低代码平台包含多种预构建组件，可以让用户非常直观地设计应用程序，并在合适的地方添加自定义代码。低代码技术允许用户快速部署，是成为用户处理快节奏的、不断变化的业务需求的推动力。 低代码平台的运作主要依赖以下三个方面： 视觉开发 低代码平台自带大量的预构建拖放式 UI 组件，用户可以通过拖放这些组件构建出一个精准符合预期的前端界面 更简易的集成 低代码平台简化了与不同数据源的集成。低代码平台可以将应用程序的前端，通过与构建的后端连接器连接到不同的数据源或API。 跨平台兼容 高可扩展性 低代码最大的特点就是高可扩展性，它允许企业根据不断变化的市场需求定制或升级应用程序，并确保随着业务增长 低代码到底可以做什么CRUD 后台CRUD（创建、读取、更新、删除）功能对几乎所有应用程序都至关重要。它通过简化和促进流程，来使应用程序的设计更容易、更具可扩展性，这些应用程序可以是基本的待办事项列表，也可以是复杂的客户支持工具 管理后台一系列资源提供查询和管理功能，业务上可以节省大量时间。同时管理后台的资源经常需要向特定用户授予基于用户和基于角色的访问权限，因此管理后台往往需要按照业务场景量身定制。 数据库 GUI/数据看板定制化表单CRM工单/项目/任务管理工具低代码平台的优点提高生产力 企业不必再将大量时间花费在内部系统的开发上，而是可以专注于公司的核心业务，提升产品。 提高公民开发者比率，从而解放开发人员的时间。 有了低代码开发平台，更多的应用程序可以在更短的时间内生产出来，时间不足不再是创新的障碍，曾经需要几个月的时间现在只需几天甚至几分钟，这是低代码平台的最大好处之一。 简化工作流生命周期的工具，包括跟踪监控和警报功能。 提高开发速度 将开发速度提高 50% 到 80%。 可加快产品开发和市场进入。 可视化界面和拖拽功能让应用的更新迭代也更加简单。 加快了验证速度，可以快速开发和部署应用程序。 大多数低代码平台都是可扩展的，提供直接的供应商接口，并允许开发人员将命令行、Web 服务和 API 转换为可复用模块。 降低开发成本 上手简单，学习成本低。 大大减少了基础性、重复性代码的开发时间。 可扩展性强 传统应用程序的升级和维护需要很长时间，但低代码开发可以快速引入新功能，容错率高。 支持跨平台的数据处理，几乎可以实现任何数字业务操作的自动化。 低代码平台的缺点灵活性有限低代码依赖于其开发平台和组件模块的内置功能，可能难以满足开发团队的特定功能诉求。每个低代码平台都提供了不同范围的定制选择和权限管理功能，因此在开发应用之前，请确保了解自己的所有使用权限。 供应商锁定团队必须使用相同的低代码平台对其开发的的应用进行更改，由于没有源代码，很难中途切换到其他平台。如果想更换低代码供应商，往往需要重新开始。 源代码的所有权您不能提取应用程序的源代码并单独进行处理，缺乏对源代码的控制，在一定程度上增加了团队业务对低代码开发平台的依赖。 如何学习低代码前端拖拽开源教学项目：https://github.com/woai3c/visual-drag-demo，提供了一些技术要点原理分析，对想入门的同学是必不可少的内容。 开源低代码框架推荐AppsmithGitHub上目前已有24.9k star，是现在GitHub上最火的低代码开发平台。Appsmith可以快速开发出管理面板、数据分析看板、客户CRM 系统、工作流等等，可以使用它们提供的免费的云端服务构建应用，也可以使用 Docker 进行私有云部署而不用担心数据泄漏。 GitHub：https://github.com/appsmithorg/appsmith官网：https://www.appsmith.com/ 优点 支持可私有化部署，同时提供免费的云端托管服务 支持开发多页面应用 多种 UI 组件可供选择 常用数据库的集成：MySQL 、MongoDB 、PostgreSQL、ElasticSearch、Redis 等 强大的开源社区支持，快速迭代 丰富的技术文档 支持 Git 版本管理 缺点 开源代码在可读性、可维护性等方面还有待加强，二次开发门槛很高 中规中矩的数据源集成数量 部分 UI 组件功能还不够完善，例如表格数据展示类型支持较少，图表组件功能比较基础，等等 用户组和权限管理功能比较简单，不适合复杂权限管理场景 ToolJet一个年轻的低代码项目，第一次发布是在 2021 年 6 月, 现在也有17.9k star。 GitHub：https://github.com/ToolJet/ToolJet官网: https://www.tooljet.com/ 一个低代码框架，可在几分钟内快速构建、部署内部工具。不仅为我们提供了具有拖放工具、默认小部件和移动布局的 UI 开发器，还提供了一个绝大多数据库支持的内置查询编辑器。此外，该框架可以连接到多个数据源，例如 Google Sheet、PostgreSQL、Redis、ElasticSearch，以及一些三方应用程序，例如 Slack、Notion、Google Sheets 。 Budibase也有17.5k star。Budibase 以其高效可靠的功能在内部系统搭建工具中脱颖而出，作为一个开源的低代码平台，能够让您快速开发内部系统，满足业务诉求, 但是Budibase 不支持组件拖拽，仅提供几种预定义的 UI 布局方式 GitHub：https://github.com/Budibase/budibase官网: https://budibase.com/ 优点 支持可私有化部署，同时提供免费的云端托管服务 支持多页应用程序开发 目前完全免费 强大的开源社区支持，快速迭代 工作流可视化做的比较好，用户可以查看/搭建自己的自动化工作流 缺点 UI 布局灵活性不够，目前只提供了基本的 UI 组件（表格、表单、文本框、文件上传等），只适用于相对简单的业务场景 支持的数据源相对较少 LowCodeEngine阿里家的基于 Low-Code Engine 快速打造高生产力的低代码研发平台 GitHub：https://github.com/alibaba/lowcode-engine官网: https://lowcode-engine.cn/site/docs/guide/quickStart/intro 我的思考低代码行业正在显著发展中，这对于代码能力有限或负担不起专业开发人员的企业来说无疑是很好的选择，尤其是对一些初创企业、中小型企业和非技术企业。而且，通过周密的规划和企业管理，您完全可以克服上面提到的低代码平台的缺点，最大限度地利用低代码平台为您带来利润。 低代码开发并不会取代传统的软件开发，但它将改变在某些领域中的软件开发，改变那些重复低效的业务，这意味着公司不需要为这种业务招聘大量的开发人员，而是安排更多的专业软件开发人员面向客户的需求以及复杂和独特的软件开发问题。 尽管相较于原生的开发模式，低代码开发平台能够显著提升开发效率，尤其适合业务变化快、预算有限、开发时间紧迫的企业应用场景；但是低代码平台也有明显的局限性，至少就目前来说，它主要用于搭建企业软件。因为此类软件架构是有一定规律的，但娱乐、社交等软件开发比较深层交互的东西低代码还是无法实现的。 国内低代码现状这里总结了很多： https://github.com/taowen/awesome-lowcode相信你能找到你要的。","link":"/176e453cd681/"},{"title":"8 个 GitHub Repos 让你成为更好的开发者","text":"我在GitHub上发现了哪些宝藏？来看看吧 1. The Book of Secret Knowledge. 100k地址：https://github.com/trimstray/the-book-of-secret-knowledge 在这里，每个人都可以找到自己想要的。但说实话，它的目标是系统和网络管理员、DevOps、测试渗透研究和安全研究人员。 2. Coding Interview University. 260k地址：[https://github.com/jwasham/coding-interview-university](https://github.com/jwasham/coding-interview-university 此处列出的项目将使您为几乎所有软件公司的技术面试做好准备。包括巨头: 亚马逊、Facebook、谷歌和微软，献给梦想成为软件工程师的你！ 3. Open Source Society University, Computer Science. 140k地址：https://github.com/ossu/computer-science 免费自学计算机科学教育。来补个课？ 4. The Art of Command Line. 137k地址：https://github.com/jlevy/the-art-of-command-line 熟练使用命令行是一项经常被忽视或被认为是神秘的技能，但它可以提高你作为一个工程师的灵活性和生产力。 这是一些关于使用命令行的笔记和提示。 5. 30 Seconds of Code. 113k地址：https://github.com/30-seconds/30-seconds-of-code 30 秒代码是 2017 年建立的，面向所有技能水平的开发人员的可访问的高质量知识库。在大型贡献者社区的贡献下创建了数百个简短的代码片段和编程文章。让软件开发更容易获得，并通过帮助人们学习编码来帮助开源社区蓬勃发展。你也可以访问网站https://www.30secondsofcode.org/ 日常开发必备！ 6. You-Dont-Know-JS 169k地址：https://github.com/getify/You-Dont-Know-JS 你不知道的JS系列。人手一本。 7. The System Design Primer. 222k 手把手教你学习如何设计大型系统 系统设计是一个很宽泛的话题。在互联网上，关于系统设计原则的资源也是多如牛毛。 这个仓库就是这些资源的组织收集，它可以帮助你学习如何构建可扩展的系统。 8. javascript-algorithms 171k地址：https://github.com/trekhleb/javascript-algorithms JavaScript实现的算法和数据结构，附有解释和进一步阅读的链接 适合准备面试的你，有时间看看刷刷算法 大赞！","link":"/f135d5b2e959/"},{"title":"14个基本的开发者工具，让你的生产力提高10倍","text":"在这样一个快节奏、有严格期限的环境中，制定一个良好的工作流程是至关重要的。因此，生产力是需要考虑的最重要指标之一。 在这篇文章中，我将分享一些最好的开发者工具来帮助你更有效地工作。 f.lux保护视力，当然最好的是闭上眼睛。 https://justgetflux.com/ ilovepdf.com 处理 PDF的平台，应有尽有。 https://www.ilovepdf.com/ ihateregex（metoohttps://ihateregex.io/ 前端处理正则必备 10 minute mail 一个临时的电子邮件地址，10分钟后过期。 squoosh.app 编解码器缩小图像 https://squoosh.app/ monkey-type 练习打字 prestigehttps://prestige.dev/ 可以在web浏览器中的HTTP模拟。 upscaler 在不损失质量的情况下，用AI增强图像分辨率。 kanboard看板 开源和自我托管的Kanboard风格的项目管理器。 原文：https://javascript.plainenglish.io/14-essential-developer-tools-to-10x-your-productivity-7ff779ec55de","link":"/0c605f4f99b5/"},{"title":"2023 年 UI/UX 设计趋势","text":"在本文中，我们重点介绍了一些我们认为将持续存在并可能在未来获得更多关注的趋势。 界面趋势 1.动作设计 运动设计正在成为界面设计的一个组成部分。动画和视频压缩的不断发展，加上互联网、浏览器和设备容量的不断增加，在不牺牲速度或效率的情况下允许在界面中进行更复杂和细微的动作。 有了直观的动画程序和动画库，设计师们更有信心尝试运动以获得更具活力和视觉吸引力的体验。模仿物理产品的动力和物理特性，设计师将能够创造出身临其境的数字交互模式。 展望未来，Motion 也将继续通过视频内容扩大其影响力。精心策划的视频片段、动态背景和古怪的视频弹出窗口将在创造迷人的品牌体验方面变得更加不可或缺（如果不是必不可少的话）。 2.滚动讲述 与其他类型的动画相比，滚动触发动画与产品的实用性关系不大，但如果做得好，它会增加无与伦比的视觉吸引力和不同信息集之间的有效转换。尽管内容和功能有限，但沉浸式滚动的讲故事能力使产品，尤其是着陆页设计栩栩如生。简而言之，滚动式叙述提供了一种叙事方式，可以提升内容、取悦用户、提高品牌认知度并提高吸引力。这是一种新的讲故事方式 3.新的更大胆的极简主义 关于极简主义下一步的发展方向几乎没有什么新奇的。极简主义的所有基本元素都在那里：专注于 没有非功能性装饰的功能对象、 畅通无阻的负空间、平面元素和图案、轻松导航和有限的调色板。使即将到来的极简主义趋势与众不同的是对现有概念的更细微和演变。 精心策划的单色调色板将是打造现代简约外观的关键。结合大型平面颜色形状、大量填充和圆形边缘，它们会产生整洁但整体“丰富”的界面。元素将保持圆润柔和的外观，结合平面图形和对比类型。进入明年，极简主义界面肯定会在不牺牲清晰度、可读性和易导航性的情况下提供更加个性化和更具表现力的体验。 4.Happy Colors / 多巴胺诱导调色板 流行于时尚界的“多巴胺着装”逐渐为人所知，它建立在近年来复古风回归的基础上，并以大胆和快乐色调的象征品质为中心。界面也不能幸免于这一趋势，因为它不断发展并重新定义个人和品牌表达的基本规则。色块、温和的纹理和治疗色调与复古元素相结合，在设计布局上野蛮的叠加。 这些多巴胺的爆发，以至于连大品牌都注意到了。尽管品牌美学在其他方面更加低调，但消费品巨头选择将多巴胺色彩的（数字）营销活动作为独立的举措，彰显自己独特的品牌个性。 5.极光渐变 如果你认为渐变趋势会慢慢走到尽头，那你就错了。渐变无处不在，它们只是在改变氛围。 多巴胺诱导调色板可以采用色块形式，并且近年来越来越流行，它们可以混合以创建引人注目的渐变色。也称为极光渐变，这些大胆的配色方案与浅色互补搭配，营造出空灵和现代的氛围。 这个名字来源于它们与北极光的相似之处，也被称为北极光。将兼容的颜色混合到网页和应用程序设计项目的极光渐变中，使整个设计看起来高雅、神秘、富有表现力和流畅。 用户体验趋势 1.跨设备体验 客户已经习惯了当今应用程序提供的跨设备操作性。随着 Apple 的产品为沉浸式产品生态系统铺平道路，用户已经明确表达了他们对无缝跨设备活动的期望。许多产品将在来年继续采用这种方式，多设备同时提供一致且可靠的实时体验。 2.情感设计 自用户体验研究以来，情感设计就一直存在。该术语强调了这样一个事实，即人类的决定基于情感而非逻辑。随着数字体验的成熟，我们正在目睹数字产品饱和，新颖性和可用性不足以脱颖而出。反过来，重新关注情感设计将继续在创造有价值的产品差异化因素和提供竞争优势方面发挥重要作用。 为了在情感设计方面实践并取得新进展，用户体验研究人员必须对用户在日常交互中的情感需求和期望进行更深入的研究。探索将希望指出在形成更高认知印象之前引起强烈和积极肯定以及本能和行为反应的互动类型。微手势、耐受性、相关微复制和个性化等特定领域将与研究齐头并进，以便为出色的产品让路。 微交互 微交互将继续成为用户体验研究的重点，以努力提高人机交互的保真度，其目的不仅仅是为了情感设计和用户界面的愉悦。尽管它们与项目后期的UI决策有关，但核心的微交互概念将继续依赖于对流程以及用户和系统触发的微交互如何导致系统反馈的密切理解。此外，研究用户心理学、心理图谱和物理产品的先例将有可能为设计良好和直观的系统反馈揭示新的机会。 总结随着技术快速融入我们的日常生活，这些趋势只是这项持续任务的一小部分。请务必使用它们来指导您的 UI 和 UX 工作，但肯定会感到有能力超越，使人机交互更进一步，从而获得更有帮助、更直观和更愉快的体验。 原文：https://medium.com/codeart-mk/ui-ux-design-trends-2023-c7285391e610","link":"/4699dcdc7c69/"},{"title":"2023年你需要知道的10个有用的CSS工具","text":"优秀的 CSS 工具列表，帮助你提高作为一个 css 开发者的生产力。 作为前端开发者，当我们在做项目时，CSS 是必不可少的。我知道现在有很多框架，使编写 CSS 代码比以前容易得多。 在这篇文章中，我将与你分享一份你在 2023 年可以使用的有用的 CSS 生成器的清单。因此，让我们直接进入主题。 CSS Gradient链接：https://cssgradient.io/ CSS Gradient 是一个很棒的工具，可以帮助你为你正在进行的项目创建渐变背景。 你可以选择和编辑你想要的颜色。该工具为你提供了很多选项来获得你想要的渐变背景并为你的 CSS 生成代码。 Animista链接：https://animista.net/ 谈到 CSS 网页动画和过渡，Animista 是一个非常有用的工具，它给你一个完整的 CSS 动画库，你可以在你的项目中使用。 该工具为你提供了一个预制的 CSS 动画集合，你可以使用。你可以重放每一种类型的动画，并按你的要求进行编辑。有很多选项，你可以自定义，生成需要的完美动画。 除此以外，该工具还允许你为动画生成 CSS 代码。当然，这样你就可以在你的项目中使用了。 Neumorphism链接：https://neumorphism.io/ 随着现在新形态设计的流行，很多设计师和网络开发人员在网络项目中使用这种设计。 Neumorphism 是一个有用的工具，可以为你的设计生成 UI CSS 代码。在创建 Neumorphism 设计时，它也是一个非常神奇的工具，可以帮助你。 这个工具给了你很多的选择。你可以挑选和编辑颜色、大小、半径、UI 距离，以及更多。你就会喜欢它。 Get Waves链接：https://getwaves.io/ 如果你想为你的网站设计生成漂亮的 SVG 波浪形，Get Waves 将帮助你解决这个问题。 该工具帮助你为你的项目生成醒目的 SVG 形状和波浪。 允许你编辑这些形状，并定制。可以复制该形状的 SVG 代码，也可以将其下载为 SVG。 Shadow Brumm链接：https://shadows.brumm.af/ Shadow Brum 是另一个很棒的 CSS 生成器工具，它允许你生成基于 CSS 的平滑阴影。 该工具使你更容易创建美丽和酷的阴影，而不必在 CSS 中写这些。 你可以得到一些设计选项，你只需自定义，如图层和透明度，然后该工具为你生成所有的 CSS 代码。 CSS Clip-path Maker链接：https://bennettfeely.com/clippy/ CSS clip-path maker 是一个工具，它可以让你轻松地创建惊人的复杂形状，然后为你生成 CSS 代码。 这个工具基于 CSS 属性 clip-path，它可以创建复杂的形状（多边形、圆形、椭圆等）。 如果你不熟悉这个 CSS 属性，不用担心，因为这个剪辑路径制作工具可以帮助你创建复杂的形状，而不需要在 CSS 中从头开始写。 PurgeCSS链接：https://purgecss.com/ 如果你想轻松删除 CSS 文件中未使用的代码，那么 PurgeCSS 是一个非常有用的工具，你可以使用。 这是一个很好的工具，尤其是在你使用 CSS 框架的时候。这是因为我们使用的大多数框架都带有许多我们并不真正需要的代码行。 因此，PurgeCSS 是一个可以帮助你减少 CSS 文件的大小，提高网站或应用程序性能的工具。 CSS Scan链接：https://getcssscan.com/ CSS 扫描是一个很棒的工具，你在你浏览的任何网页上查看 CSS 代码。你只需要将鼠标悬停在网页上的某个元素上，然后该工具就会为你生成 CSS 代码。 除此之外，你可以轻松地复制和编辑 CSS 代码，只需一次点击。如果你不想总是花很多时间使用 “检查元素 “的浏览器功能来检查 CSS，这是一个很好的工具。 Fancy Border Radius Generator链接：https://9elements.github.io/fancy-border-radius/ 如果你想使用 CSS 属性 border-radius 创建花哨的复杂形状，在指定该属性的值时，你将不得不使用八个值。 这就是为什么 Fancy Border Radius 会发挥作用，帮助你建立复杂的有机形状，并为你生成 CSS 代码，而不必从头开始写。 CSS Grid Generator链接：https://cssgrid-generator.netlify.app/ 如今，使用 CSS 网格是在你的网页上创建响应式网格布局的一个好方法。在为你的网站或应用程序创建网格布局时，有许多 CSS 网格属性和功能可以使用。 这就是 CSS 网格生成器发挥作用帮助你的原因。它是一个很棒的工具，可以为你生成 CSS 网格代码，可以帮助你了解更多关于 CSS 网格的知识，容易使用。你只需要编辑列、行和单位。因此，如果有必要，该工具将生成 CSS 甚至 HTML 代码。 Bonus Tool: CSS buttons generator链接：https://markodenic.com/tools/buttons-generator/ 这个很棒的按钮生成器工具可以让你生成很多漂亮的按钮 CSS 样式和效果，你可以在你的项目中使用。 这个工具包含了很多很酷的按钮，有很棒的 CSS 悬停效果。你只需要点击你想要的按钮，然后你就会得到 CSS 代码。 从上面的列表中你可以看到。如果你想节省时间并提高你的 CSS 编码效率，这些工具会非常有益。 它们使你能够在短时间内创造出令人惊奇的东西，而不需要编写大量的 CSS 代码。 公号同步更新，欢迎关注 👻 https://javascript.plainenglish.io/10-useful-css-generator-tools-that-you-should-use-in-2023-14fde4cd225d","link":"/81fc7c0f9e5d/"},{"title":"2款免费好用的AI工具","text":"下面给大家分享的网站都是良心网站，可以让国内用户免费使用chatgpt，大家请不要恶意使用！！！ 百晓生该网站无需注册即可免费使用，大家打开网站即可使用, 电脑手机都能用。 强大且多元化的AI工具箱，提供高质量的AI服务，可以帮助用户更好地完成各种任务工具箱包括小红书文案生成工具，自动生成吸引人的小红书文案，适合小红书营销的朋友。还有英文翻译，程序员、代码优化可以帮你检查并且优化代码。还有很多有趣的工具，大家可以自己去探索。 直接扫码直达 周报生成器一写周报就头大？让它来帮你生成完整周报. 输入：修复bug 是不是感觉很爽。 直接扫码直达","link":"/558ff96f4752/"},{"title":"2023年这7个项目可以帮助你成为前端高手","text":"无论你是编程的新手还是已经是这个行业的资深开发者，学习新的概念和语言/框架，都必须跟上快速变化的步伐。以 React 为例–四年前由 Facebook 开放源代码，它已经成为全球 JavaScript 开发者的头号选择。当然，Vue 和 Angular 也有其追随者基础。还有 Svelte 和 Next.js 或 Nuxt.js 等通用框架。还有 Gatsby……还有，还有，还有。如果你想成为一名专业的 JavaScript 开发者，你至少应该有一些不同框架和库的经验–除了用好的、老的 JS 做功课。 为了帮助你成为一个前端高手，我收集了九个项目，每个项目都有一个特定的主题和一个不同的 JavaScript 框架或库作为技术栈，你可以建立并添加到你的计划中。记住，没有什么比实际造东西更能帮助你。 使用 React 开发一个电影搜索应用（用 hooks）首先，你可以从使用 React 构建一个电影搜索应用开始。下面是一个最终应用程序的图片： 你将学到什么在构建这个应用程序时，你将使用相对较新的 Hooks API 提高你的 React 技能。这个例子项目使用了 React 组件、许多钩子、一个外部 API，当然还有一些通过 CSS 进行的样式设计。 技术栈 带有钩子的 React 创建 React-app JSX CSS 你可以在这里找到这个项目的例子https://www.freecodecamp.org/news/how-to-build-a-movie-search-app-using-react-hooks-24eb72ddfaf7/, 跟着教程走。 用 Vue 开发一个聊天网站为你提供的另一个伟大的项目是使用我最喜欢的 JavaScript 库建立一个聊天应用程序： VueJS。这个应用程序看起来会是这样的： 你将学到什么按照本教程，你将学会如何从头开始设置一个 Vue 应用程序–创建组件、处理状态、创建路由、连接到第三方服务，甚至处理认证。 技术栈 Vue Vuex Vue Router Vue CLI Pusher CSS 这确实是一个很好的项目，可以让你开始使用 Vue–或者提高你现有的技能–以应对 2023 年的发展。你可以在这里找到该教程。https://www.sitepoint.com/pusher-vue-real-time-chat-app/ 用 Angular 8 开发一个漂亮的天气应用 你将学到什么这个项目将教会你宝贵的技能，同时从头开始创建一个应用程序–从设计到开发，一直到生产就绪的部署。 技术栈 Angular 8 Firebase 服务器端渲染 带有网格布局和 Flexbox 的 CSS 移动友好和响应性 黑暗模式 UI 我非常喜欢这个项目的一点是，你不会孤立地学习东西。相反，你学习的是整个开发过程–从设计到最后的部署。 https://github.com/hamedbaatour/Minimus 用 Svelte 开发一个待办事项应用Svelte 是社区里的一个新人–至少与 React、Vue 和 Angular 相比是这样。尽管如此，它仍是 2023 年的热门之一。好吧，待办事项应用程序不一定是最热门的话题，但这确实会帮助你磨练你的 Svelte 技能。它看起来会是这样的： 你将学到什么本教程将告诉你如何使用 Svelte 3 从头到尾制作一个应用程序。它使用了组件、样式和事件处理程序。 技术栈 Svelte 3 组件 CSS 样式 ES 6 语法 https://github.com/seeschweiler/svelte-todo-app 用 Next.js 开发一个电子商务的购物车Next.js 是创建 React 应用程序的最流行的框架，支持开箱即用的服务器端渲染。这个项目将告诉你如何开发一个看起来像这样的电子商务购物车项目 你将学到什么在这个项目中，你将学习如何设置 Next.js 开发环境–创建新的页面和组件，获取数据，以及设计和部署 Next 应用程序的风格。 技术栈 Next.js 组件和页面 数据获取 样式设计 部署 SSR 和 SPA 电子商务,电商项目，来学习新的东西总是很好。你可以在这里找到该教程: https://snipcart.com/blog/next-js-ecommerce-tutorial-example 使用Nuxt.js开发一个完整的多语言博客网站Nuxt.js之于Vue，就像Next.js之于React一样：一个伟大的框架，将服务器端渲染和单页应用的力量结合起来。你可以创建的最终应用会是这样的： 你将学到什么这个示例项目将教你如何使用Nuxt.js建立一个完整的网站–从最初的设置到最后的部署。它使用了Nuxt提供的许多很酷的功能，如页面和组件，以及用SCSS进行样式设计。 技术栈 Nuxt.js 组件和页面 Storyblok模块 Mixins 用于状态管理的Vuex 用于样式设计的SCSS Nuxt中间件 这是一个非常齐全的项目，涵盖了Nuxt.js的许多功能。我个人很喜欢用Nuxt工作，所以你真的应该试试这个项目，因为它也会让你成为一个更好的Vue开发者。 https://www.storyblok.com/tp/nuxt-js-multilanguage-website-tutorial 用Gatsby开发博客Gatsby是一个伟大的静态网站生成器，在引擎盖下使用React和GraphQL。这就是这个项目的成果： 你将学到什么在本教程中，你将学习如何利用Gatsby建立一个优秀的博客，用于撰写你的文章，同时利用React和GraphQL。 技术栈 Gatsby React 图形QL 插件和主题 MDX/Markdown Bootstrap CSS 模板 如果你曾经想开一个博客，这是一个很好的例子，说明如何通过利用React和GraphQL来实现这个目的。我并不是说WordPress总是一个糟糕的选择，但是通过Gatsby，你可以在使用React的同时创建高性能的网站–这是一个了不起的组合。 https://blog.bitsrc.io/how-to-build-a-blog-with-gatsby-and-boostrap-d1270212b3dc","link":"/2f1004620f41/"},{"title":"4个React技巧，瞬间改善你的代码","text":"扎实的React知识是前端开发者最宝贵的技能之一。许多公司都在不断寻找React开发人员，我想分享四个对我编写更好的React代码有帮助的提示。我希望你会发现一些新的和有用的东西 场景一先上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142export default function App() { const [user, setUser] = useState({ name: \"\", surname: \"\", address: \"\" }); // handler 1!!! const handleNameChange = (e) =&gt; { setUser((prev) =&gt; ({ ...prev, name: e.target.value })); }; // handler 2!!! const handleSurnameChange = (e) =&gt; { setUser((prev) =&gt; ({ ...prev, surname: e.target.value })); }; // handler 3!!! const handleAddressChange = (e) =&gt; { setUser((prev) =&gt; ({ ...prev, address: e.target.value })); }; return ( &lt;&gt; &lt;input value={user.surname} onChange={handleSurnameChange} /&gt; &lt;input value={user.address} onChange={handleAddressChange} /&gt; &lt;/&gt; );} 如果我们还需要一个输入怎么办？我们应该为它创建另一个处理程序吗？如果你懂React中的函数式编程，我想你应该懂了。 解决方案： 123456789101112131415161718192021222324export default function App() { const [user, setUser] = useState({ name: \"\", surname: \"\", address: \"\" }); const handleInputChange = (field) =&gt; { return (e) =&gt; { setUser((prev) =&gt; ({ ...prev, [field]: e.target.value })); }; }; ( &lt;&gt; &lt;input value={user.name} onChange={handleInputChange(\"name\")} /&gt; &lt;input value={user.surname} onChange={handleInputChange(\"surname\")} /&gt; &lt;input value={user.address} onChange={handleInputChange(\"address\")} /&gt; &lt;/&gt; );} 场景2阅读下面代码： 12345678910111213141516171819202122function Account({type}) { let Component = UsualAccount if (type === 'vip') { Component = VipAccount } if (type === 'moderator') { Component = ModeratorAccount } if (type === 'admin') { Component = AdminAccount } return ( &lt;div className='account'&gt; &lt;Component /&gt; &lt;AccountStatistics /&gt; &lt;/div&gt; )} 解决方案： 1234567891011121314151617const ACCOUNTS_MAP = { 'vip': VipAccount, 'usual': UsualAccount, 'admin': AdminAccount, 'moderator': ModeratorAccount,}function Account({type}) { const Component = ACCOUNTS_MAP[type] return ( &lt;div className='account'&gt; &lt;Component /&gt; &lt;AccountStatistics /&gt; &lt;/div&gt; )} 如果你需要根据变量来显示不同组件，你可以这样实现。使用这种简单的策略使组件更具有声明性，简化了代码理解。此外，它使进一步扩展功能变得更加容易。 场景3请阅读代码： 12345678910111213141516171819function useItemsList() { const defaultItems = [1, 2, 3, 4, 5] const [items, setItems] = useState(defaultItems) const toggleArrayItem = (arr, val) =&gt; { return arr.includes(val) ? arr.filter(el =&gt; el !== val) : [...arr, val]; } const handleToggleItem = (num) =&gt; { return () =&gt; { setItems(toggleArrayItem(items, num)) } } return { items, handleToggleItem, }} 解决方案： 12345678910111213141516171819202122const DEFAULT_ITEMS = [ 1, 2, 3, 4, 5]const toggleArrayItem = (arr, val) =&gt; { return arr.includes(val) ? arr.filter(el =&gt; el !== val) : [...arr, val];}function useItemsList() { const [items, setItems] = useState(DEFAULT_ITEMS) const handleToggleItem = (num) =&gt; { return () =&gt; { setItems(toggleArrayItem(items, num)) } } return { items, handleToggleItem, }} 我们的想法是将不需要React组件生命周期方法的逻辑与组件本身分开。这通过使依赖关系更加明确来提高代码的清晰度。因此，阅读和理解组件变得更加容易。 https://medium.com/javascript-in-plain-english/4-react-tips-to-instantly-improve-your-code-7456e028cfa3#fd60","link":"/42c8f8d219f2/"},{"title":"8个JavaScript技巧","text":"有很多方法可以优化我们的 JavaScript 代码，本文总结了我在工作中经常使用的 8 个 JavaScript 技巧，希望它也能帮助你。 减少使用 if-else在编写两个以上的 if … else 时，是否有更好的优化方法?如下代码，我们需要根据一个汉堡包的名字来计算它的价格。 12345678910const getPriceByName = (name) =&gt; { if (name === '🍔') { return 30; } else if (name === '🍨') { return 20; } else if (name === '🍿') { return 10; }};console.log(getPriceByName('🍔')); // 30 更好的写法 ✅ 1234567891011const getPriceByName = (name) =&gt; { const foodMap = { '🍔': 30, '🍨': 20, '🍿': 10, // 其他食物 // ... }; return foodMap[name];};console.log(getPriceByName('🍔')); // 30 使用 “filter”和 “map”现在，如果让你找到属于第 1 组的食物，你会如何找到它？比如下面这样数据： 123456789101112131415161718const foods = [ { name: '🍔', group: 1, }, { name: '🍨', group: 1, }, { name: '🍿', group: 2, }, { name: '🍵', group: 1, },]; 12345678910// ❌const names = [];for (let i = 0, len = foods.length; i &lt; len; i++) { if (foods[i].group === 1) { names.push(foods[i].name); }}// ✅const names = foods.filter((food) =&gt; food.group === 1).map((food) =&gt; food.name);console.log(names); // [ '🍔', '🍨', '🍵' ] 使用解构法交换两个值现在我有汉堡包，你有巧克力。我们是好朋友，想交换食物。我们通常怎么做呢？ 123456789101112// ❌let myFood = '🍔';let yourFood = '🍫';let tempFoot = myFood;myFood = yourFood;yourFood = tempFoot;console.log(myFood, yourFood); // 🍫 🍔// ✅let myFood = '🍔';let yourFood = ('🍫'[(myFood, yourFood)] = [yourFood, myFood]);console.log(myFood, yourFood); // 🍫 🍔 Object.entries如果你想知道仓库里食品的名称和价格，你应该怎么做？ 12345678const foodMap = { '🍔': 30, '🍨': 20, '🍿': 10, '🍫': 5,};// pay attention hereObject.prototype['🌭'] = 40; 1234// ❌ for in遍历for (const key in foodMap) { console.log(key, foodMap[key]);} 1234// ✅Object.entries(foodMap).forEach(([key, value]) =&gt; { console.log(key, value);}); 使用 Object. entries 至少有两个好处： 只打印对象上的属性，原型上的属性被忽略。直接获取对象的值，而不是用 obj[key]来读取。 扁平化数组这里有一组这样的数据 1const foods = [ [ '🍔', [ '🍫' ] ], [ '🍨', [ '🍿', [ '🍵' ] ] ] ] 12345678910// ❌const flattenFoods = (foods) =&gt; { return foods.reduce((res, food) =&gt; { return res.concat(Array.isArray(food) ? flattenFoods(food) : food); }, []);};console.log(flattenFoods(foods)); // ['🍔', '🍫', '🍨', '🍿', '🍵']// ✅ 是不是很简单foods.flat(Infinity); // ['🍔', '🍫', '🍨', '🍿', '🍵'] ~~ 技巧哇，今天是万圣节，为了庆祝这个节日，所有的食物都打折，小数点都被抹去。怎么实现 123456789101112131415161718192021const foods = [ { name: '🍔', price: 30.89, }, { name: '🍨', price: 20.71, }, { name: '🍿', price: 10.31, },];const discountedFoods = foods.map((it) =&gt; { return { name: it.name, price: ~~it.price, };});console.log(discountedFoods); 使用 reduce 来计算总和计算总和： 123456789101112131415161718192021222324252627282930313233const foods = [ { name: '🍔', price: 30, amount: 10, }, { name: '🍨', price: 20, amount: 3, }, { name: '🍿', price: 10, amount: 5, }, { name: '🍵', price: 5, amount: 9, },];// ❌let sum = 0;foods.forEach((food) =&gt; { sum += food.price * food.amount;});console.log(sum); // 455// ✅let sum = foods.reduce((res, food) =&gt; res += food.price * food.amount, 0)console.log(sum) // 455 console.table我们经常使用console.log来打印一些信息，但有时并不那么直观。 1234567891011121314151617181920212223const foods = [ { name: '🍔', price: 30.89, group: 1, }, { name: '🍨', price: 20.71, group: 1, }, { name: '🍿', price: 10.31, group: 2, }, { name: '🍵', price: 5.98, group: 2, },]console.log(foods) 原文：https://javascript.plainenglish.io/8-javascript-tricks-to-make-you-a-better-programmer-8d59c75736d2 公号同步更新，欢迎关注 👻","link":"/75609faca357/"},{"title":"React18 | useTransition","text":"React18 所做的最有趣的实现是并发性，我们可以优先考虑某些状态而不是其他状态，以便我们可以保持网站的整体用户体验响应。 为此，React18 引入了 startTransition 的概念，也可以使用 useTransition 钩子来利用它。 通过使用 useTransition，我们可以告诉 React 某些状态的优先级较低，因此可以先执行高优先级状态，这最终会改善用户体验，因为用户可以很快看到 UI 上的大部分改进更新。 useTransition 钩子返回 2 个元素的数组。第一个是 isPending 元素，它告诉低优先级状态仍在等待处理，第二个是 startTransition，它告诉 React 某些状态是低优先级的。 使用 useTransition 挂钩的另一个示例 -某些 UI 更新应尽快执行（在输入字段中键入，从下拉列表中选择一个值），而其他更新则可以具有较低的优先级（过滤列表）。 让我们通过示例来看一下 -我们将尝试填充数字列表，并在顶部添加搜索框。只要在搜索框中输入任何号码，列表就会显示匹配的号码。 示例 1 —上面的示例没有使用 useTransition 钩子 1let copyList = null; 1234567891011121314151617181920212223242526272829303132const MyComp = (props) =&gt; { let [list2, setList2] = React.useState([]); React.useEffect(() =&gt; { for (let i = 0; i &lt; 15000; i++) { setList2((val) =&gt; { return [...val, i]; }); } }, []); const handleChange = (event) =&gt; { if (copyList === null) { copyList = JSON.parse(JSON.stringify(list2)); } list2 = JSON.parse(JSON.stringify(copyList)); // filtering the list based on the value typed in textbox if (event.target.value) { list2 = list2.filter((v) =&gt; v == event.target.value); } }; return ( &lt;div&gt; &lt;input onChange={handleChange} /&gt; {list2.map((val, key) =&gt; { return &lt;div key={key}&gt;{val}&lt;/div&gt;; })} &lt;/div&gt; );}; 123const rootElement = document.getElementById(\"app\");const root = ReactDOM.createRoot(rootElement);root.render(&lt;MyComp /&gt;); 尝试执行上述代码后，您会发现只要您尝试在键入后删除搜索框中的 “否”，用户界面就会一团乱，这是很糟糕的用户体验，而允许用户在搜索框中键入值是比过滤列表更重要的任务。 示例 2- 让我们使用 useTransition 钩子来改进它 1let copyList = null; 12const MyComp = (props) =&gt; { let [list2, setList2] = React.useState([]); 12345678910111213141516171819202122232425262728293031323334353637// using useTransition hook let [isPending, startTransition] = React.useTransition(); React.useEffect(() =&gt; { for(let i = 0; i &lt; 15000; i++) { setList2((val) =&gt; { return [...val, i]; }); } }, []); const handleChange = (event) =&gt; { if (copyList === null) { copyList = JSON.parse(JSON.stringify(list2)); } list2 = JSON.parse(JSON.stringify(copyList)); // filtering the list based on the value typed in textbox by using useTransition hook startTransition(() =&gt; { if(event.target.value) { list2 = list2.filter((v) =&gt; (v == event.target.value)); } setList2(list2); }); } return( &lt;div&gt; {isPending ? 'Wait searching...' : ''} &lt;input onChange={handleChange} /&gt; { list2.map((val, key) =&gt; { return (&lt;div key={key}&gt;{val}&lt;/div&gt;) }) }&lt;/div&gt; );} 123const rootElement = document.getElementById(\"app\");const root = ReactDOM.createRoot(rootElement);root.render(&lt;MyComp /&gt;); 试着运行上述代码，你就会发现之前代码中出现的问题，即当用户试图从搜索框中移除值时，这个问题将不复存在，用户在搜索框中键入值的体验将变得流畅，一旦用户停止在搜索框中键入值，列表就会被过滤。 希望本文能帮助您在项目中有效利用 useTransition 钩子。 原文：https://medium.com/@bansal.suneet/react18-usetransition-hook-very-effective-7a93ea1b1dff 公号同步更新，欢迎关注 👻","link":"/c89b26425a28/"},{"title":"Typescript 4.5 | 新特性总结来了","text":"Typescript 4.5 提供了许多有用的功能。我们应该花些时间了解这些功能，以便在日常编码中加以利用，提高代码质量。这些功能有助于优化代码，提高代码的可读性和可维护性。 将模板字符串类型作为判别因素该功能使 Typescript 能够识别并成功地对以模板字符串作为类型的值进行类型检查。下面是一个示例： 使用 Typescript4.4 或更旧版本时，上述代码的类型检查会失败，但现在使用 Typescript4.5 可以成功进行类型检查。 禁用导入省略在某些情况下，TypeScript 无法检测到您正在使用导入。例如，下面的代码 123import { Animal } from \"./animal.js\";eval(\"console.log(new Animal().isDangerous())\"); 公号同步更新，欢迎关注 👻","link":"/2663bc10b94f/"},{"title":"PC网站如何实现微信扫码登录","text":"不管你运营什么类型的网站，用户注册都是很重要的一个环节，用户注册的方式也是很多的，比如邮箱注册、手机号注册、第三方授权登录等。其中，第三方授权登录是最常用的一种方式，微信扫码登录是其中的一种，但是微信扫码登录的实现方式有很多种，比如公众号扫码，小程序扫码，网页扫码等。 本文将介绍一种简单的实现方式。 技术栈 后端：NodeJs / 企业级框架 Egg.js 前端：Vue 微信小程序：uni-app 数据库：MySQL 实现思路 PC 端网站生成一个二维码，定时 3s 轮询请求接口，判断用户是否扫码，如果扫码，则返回用户的微信信息。 用户微信扫码后，会跳转到微信小程序，小程序打开点击注册按钮，会获取到用户的微信信息，然后将用户信息发送到后端。 后端接收到用户信息后，判断用户是否已经注册，如果已经注册，则直接登录，如果没有注册，则将用户信息 openid 和 mobile 保存到数据库中，新建用户，生成一个 token，返回给 PC 端，展示用户登录成功。 微信小程序展示用户扫码成功。 实现步骤 需要申请一个微信小程序，用于扫码登录，申请地址：https://mp.weixin.qq.com/ 建表 PC 端网站生成二维码 实现效果如下： 微信小程序扫码登录 后端接口实现 路由：app/router.js 生成带唯一 scene 参数的小程序码 app/controller/login.js","link":"/338a7dc81d45/"},{"title":"Top VS Code扩展插件","text":"Visual Studio Code 无疑是当今最流行的代码编辑器。它是微软为 Windows、Linux 和 macOS 开发的轻型代码编辑器。它包括各种功能，如语法高亮，调试，智能代码完成，片段，嵌入式 Git，代码重构等。与市场上的其他代码编辑器相比，VS Code 提供了更好的性能和稳定性。下面就来分享开发必备的 VS Code 插件！ Git LensGitLens 增强了 Git 的功能。GitLens 帮助你更好地理解代码。这个强大且功能丰富的工具有助于快速查看代码的变化，如谁、为什么、何时修改了某一行或代码块。你可以找到代码历史，进一步了解代码的演变过程和原因。有了这个工具，你可以毫不费力地探索一个代码库的历史和演变。 以下是 GitLens 提供的一些独特功能： 轻松地通过文件历史进行修订导航（向前和向后） 代码块上展示最近的提交和作者数量 状态栏上注释显示修改当前行的提交和作者 代码更改 - 高亮显示任何本地（未发布）更改或最近提交更改的行 热力图 - 显示相对于文件中的所有其他更改和现在（热 vs. 冷）行的最近和频繁的更改情况 https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens Github CopilotGitHub Copilot 使用 OpenAI Codex，从你的编辑器中实时推荐代码。经过对数十亿行公共代码的训练，GitHub Copilot 将包括注释和方法名称在内的自然语言提示转化为几十种语言的编码建议。 GitHub copilot 的主要目标是使软件工程师更容易在项目中进行更有效的合作，通过对彼此的代码进行实时审查，并在开发周期中随时提供反馈，从而提高开发效率。 https://marketplace.visualstudio.com/items?itemName=GitHub.copilot Peacock开发人员喜欢打开 VS Code 的多个窗口，因为他们同时在一个以上的项目上工作。例如，后端和前端项目可以在两个独立的 VS Code 实例中打开，开发人员可能想从一个项目移到另一个项目。使用这个扩展，开发者可以改变每个项目窗口的颜色，这样就可以快速识别他们正在工作的项目或 repo。 如果你喜欢 Tailwind CSS，那么这就是一个必须拥有的扩展。它是一个免费的扩展，由 Tailwind 实验室（bradlc）发布。这个扩展为 Tailwind 类提供了自动完成、语法高亮和提示功能。有了这个扩展，开发者不需要记住所有实用类的准确拼写，也不需要花时间把它们打出来。 https://marketplace.visualstudio.com/items?itemName=johnpapa.vscode-peacock ES7+ React/Redux/React-Native snippets如果你是一个真正的 ReactJS 开发者，那么这是一个你必须拥有的片段，因为它只是为你做了正确的事情。这个插件为你提供了 ES7 中的 JavaScript 和 React/Redux 片段，具有 VS Code 的 Babel 插件功能。 https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets JavaScript Code Snippets这个扩展包含了 Vs Code 编辑器的 ES6 语法的 JavaScript 代码片段（同时支持 JavaScript 和 TypeScript）。该扩展支持 JS、TypeScript、JS React、TS React、HTML 和 Vue。 https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets Prettier — Code formatter开发人员对如何格式化代码结构使之可读有不同的意见。Prettier 的创建是为了缓解这一挑战，并确保开发团队内部有一个统一的代码格式。 Prettier 对你的 JavaScript 代码进行了统一的重新编排，使之易于阅读和理解代码。这个插件有助于格式化间距、变量声明、分号、尾部逗号和更多。 你可以配置 Prettier 在保存文件或提交文件到版本控制系统（如 Git、SVN）时对文件进行格式化。这样，你就不必担心你的源代码的格式问题，Prettier 会照顾到这一点。 https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode ESLintESLint 是一个开源项目，可以帮助你发现和修复你的 JavaScript 代码的问题。无论你是在浏览器中还是在服务器上编写 JavaScript，无论是否有框架，ESLint 都可以帮助你的代码活出它的最佳状态。 https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint Vscode-Icons拥有描述性的图标可以帮助你区分项目中的文件和文件夹。在你的项目中拥有图标可以使你的项目更加有趣和有吸引力。下图描述了两个 VS Code 标签之间的不同。 https://marketplace.visualstudio.com/items?itemName=vscode-icons-team.vscode-icons TODO Highlight这个插件可以让你在代码中突出显示 TODO、FIXME 和其他注释。这确实是一个有用的插件，可以突出注释，如 NOTE：，TODO：，DEBUG：。自定义设置也相当广泛，使其成为开发人员的完美选择，从而使你在任何项目中的注释水平提高。 https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight SQL Server一个用于开发 Microsoft SQL Server、Azure SQL 数据库和 SQL 数据仓库的扩展，具有丰富的功能，包括： 连接到 Microsoft SQL Server、Azure SQL Database 和 SQL Data Warehouses。 创建和管理连接配置文件和最近使用的连接。 利用 IntelliSense、Go to Definition、T-SQL 片段、语法着色、T-SQL 错误验证和 GO 批量分离器编写 T-SQL 脚本。 执行你的脚本，并在一个简单易用的网格中查看结果。 将结果保存为 json 或 csv 文件格式并在编辑器中查看。 可定制的扩展选项，包括命令快捷键和更多。 Run运行多种语言的代码片断或代码文件：C, C++, Java, JavaScript, PHP, Python, Perl, Perl 6, Ruby, Go, Lua, Groovy, PowerShell, BAT/CMD, BASH/SH, F# Script, F# ( .NET Core), C# Script, C# ( .NET Core), VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml Script, R, AppleScript, Elixir, Visual Basic .NET, Clojure, Haxe, Objective-C, Rust, Racket, Scheme, AutoHotkey, AutoIt, Kotlin, Dart, Free Pascal, Haskell, Nim, D, Lisp, Kit, V, SCSS, Sass, CUDA, Less, Fortran, Ring, Standard ML 等等 https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner Tabnine AI Autocomplete for Javascript, Python, Typescript, PHP, Go, Java, Ruby &amp; moreTabnine 是人工智能代码完成助手，已经被数百万开发人员信任，以扩大编码的准确性和提高生产力。无论你是一个新的开发人员还是一个经验丰富的专业人员，无论你是独自工作还是作为团队的一部分，Tabnine 人工智能助手都会在大多数流行的编码语言和所有你最喜欢的 IDE 中建议团队定制的代码完成方式。 Tabnine 由复杂的机器学习模型驱动。它是在 GitHub 上超过 10 亿行的开放源代码上训练出来的。 Tabnine 在你写的时候建议和预测代码。这个强大的扩展程序加速了你的开发，为你节省了大量的时间，将你的编码时间减少了一半。目前，它支持几乎所有流行的编程语言，包括 Python、Javascript、Java 和 React。 Tabnine 的团队学习算法研究你的团队的代码、偏好和模式，不断学习和适应。与团队成员的每一次互动都会放大代码完成的准确性。 https://marketplace.visualstudio.com/items?itemName=TabNine.tabnine-vscode Visual Studio IntellicodeVisual Studio IntelliCode 扩展为 Visual Studio Code 中的 Python、TypeScript/JavaScript 和 Java 开发人员提供人工智能辅助开发功能，并在理解你的代码上下文的基础上结合机器学习进行 ai 协助开发。 https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode 你欢迎你来推荐你喜爱的插件。 原文：https://medium.com/@ibrahimzahir7/top-vs-code-extensions-you-need-for-your-next-project-33b5e2ab8269","link":"/83a0a39efd12/"},{"title":"什么？听说你还没用上GitHub Copilot","text":"GitHub Copilot 是什么他是目前我用的 ai 编程最好的工具，没有之一。 Copilot 在 GPT-3 支持下，帮助在您的编辑器中自动生成代码。它可作为 Visual Studio Code、JetBrains IDE 套件和 Neovim 等扩展使用。AI 工具理解 TypeScript、Python、JavaScript、Ruby 和数十种其他常见语言，因为 AI 建议来源于 Github 公共存储库中 的开源项目，当您激活了 GitHub Copilot 插件，基于您正在编写的代码上下文线索，他会自动适应你编写代码的格式，风格。你只要编写所需代码的描述或者函数名称，Copilot 就会非常快速，自动完成你所需的代码。 它不只是创建一种解决方案，而是创建多个，你可以选择你想要的一个。随着你用的次数越来愈多，他会越来越懂你。写出的代码完全符合你的心意，比老公还要贴心，就是这么神奇。 当然，你会发现，有些建议并不总是有效，甚至没有意义，GitHub Copilot 并不总是编写出完美的绝对正确的代码。他会尽最大努力去尝试和理解开发者的意图。再给你输出代码之前，他不会实际上的测试验证代码。所以你来使用这些代码，你还是要认真的审查下，除非你是传说中的大拿。 GitHub Copilot 仍然只是一个工具。它甚至还不能取代对人类开发者的需求。你不能仅仅依靠 Copilot，接受建议并进行修改代码，开发任务的责任还是在开发者本人身上。我们所要做的就是利用好提高自己效率的工具，为自己所用 如何安装 GitHub Copilot 要添加 GitHub Copilot，请打开你的 GitHub 并转到设置。 在左侧菜单中选择 GitHub Copilot 并勾选 Allow 以启用它，然后单击 Save 按钮以保存。 现在打开 Visual Studio Code 并转到 Extensions（扩展），在搜索栏中搜索 GitHub Copilot。 安装 Github Copilot，并重新启动你的 Visual Studio Code。 在底部，你会看到 GitHub Copilot 已被激活。 开发中怎么使用 GitHub Copilot操作实例一：将注释转换为代码只需输入几个模式示例即可 操作实例二：自动填充重复代码GitHub Copilot 是开发人员加速编写重复代码的理想方式。如果您正在编写大量样板代码，只需输入几个模式示例即可。然后 Copilot 将处理其余部分。 图片来自：https://www.hayo.com/ 在这个例子中，常量变量以秒为单位开始。一旦第二行显示了将分钟乘以秒的 const，Copilot 就会识别出模式并自动完成代码，包括小时、天、周、月和年。这五行额外的代码可以通过单击一次来编写。在规模上，这将节省大量编程时间，特别是对于较大的块而言 操作实例二：完全使用 Copilot 创建应用程序LogRocket 上找到了一篇由一位英国软件工程师撰写的优秀案例研究。在一个星期内，Copilot 完全依靠 Copilot 的建议。他也不会写任何新的代码, 创建了一个简单的语录生成应用程序。后续就不知道了。 更快更强 接受建议：Tab 拒绝建议：Esc 打开 Copilot：Ctrl + Enter （会打开一个单独的面板，展示 10 个建议） 下一条建议：Alt/Option + ] 上一条建议：Alt/Option + [ 触发行内 Copilot：Alt/Option + \\ （Coplit 还没有给出建议或者建议被拒绝了，希望手工触发它提供建议） 什么？不免费了？嫌贵目前 Copilot 已经不再免费，需要支付 10 美元/月或者 100 美元/年。如果你是教师学生，可以白嫖，如果你不是你可以走淘宝认证 购入截图放这里，2 年 20 块。 希望每个人都能用上ai。","link":"/80546147781c/"},{"title":"关于npm你知道多少？","text":"npm是Node.js的包管理器，用于安装、管理和共享JavaScript代码包。它是Node.js生态系统中最受欢迎的工具之一。 打开一个软件包的文档页面如果你想看下lodsh深拷贝的使用方法，你会怎么做？打开谷歌/百度搜索下吗？ 事实上，npm可以帮助你快速实现。你只需要运行npm docs [package]就可以直接打开package的文档 打开一个软件包的GitHub repo想知道一个包的源代码，我可以只在github上搜索包的名字吗？ 答案是否定的，npm可以帮助你快速打开一个包的GitHub repo 检查软件包是否有过时的依赖在你的项目中运行npm outdated命令，它将检查所有软件包的当前版本、所需版本和最新版本。 查看一个软件包的所有历史版本你知道如何查看一个软件包的所有历史版本吗？ 是的，我们可以通过npm的在线网站做到这一点。https://www.npmjs.com/package/lodash?activeTab=versions但是还有更简单的办法： 在你的项目中寻找有风险的包npm audit 允许开发人员分析复杂的代码，并查明特定的漏洞和缺陷。 npm audit fix 检测项目依赖中的漏洞并自动安装需要更新的有漏洞的依赖，而不必再自己进行跟踪和修复。 查看npm包的细节好吧!也许这个命令不是很有用，但你可以用它来了解一个软件包的很多情况，如它的作者、联系信息等。 npm xmas当你运行npm xmas时，你会看到一棵圣诞树。 希望本文对你有用，并给你带来会心一笑。如果你有任何问题或建议，请在下面留言。 原文链接：https://javascript.plainenglish.io/as-a-front-end-engineer-8-useful-npm-coding-techniques-that-you-should-use-bc30b8503ba4","link":"/0c73e67dfff5/"},{"title":"做一个游戏小项目有多简单？","text":"认识一个朋友，学了很多年的 python, 还停留在 helloworld 阶段，每次拿起又放下，是不是很熟悉？每天都在想，我要学编程，我要学编程，但是又不知道从何学起，学了一点又不知道怎么用，这样的循环往复，最后就放弃了。其实任何知识的学习一定是源于内心的真实的喜欢，带给你正向的热情和感动。才会让你一直坚持下去。不管 debugger 多少次，bug 多少次，都不会放弃。 很多人对编程，代码有着自然的畏惧，其实编程是一件很有趣的事情，只要你找到了适合自己的方式，你就会爱上它。 作为前端开发者，你不妨尝试着用前端技术开发一个小型的游戏项目来提升自己的技能和乐趣。 Pacman比如这款游戏，基于HTML5的吃豆人游戏(本游戏由 passer-by.com 制作)，你可以在这里玩到：https://passer-by.com/pacman/ 你可以看到这款游戏，仅仅用了html5,js来完成的。内置了12个关卡，游戏还是十分流畅的。有兴趣可以一边玩一玩，看看源码。 源码在此：https://github.com/mumuy/pacman Snake Game当年这款游戏多火啊，很多手机都内置了这款贪吃蛇游戏，嗯那还是诺基亚手机的时代。同样的html5+js 就可以完成这款游戏。 玩一玩：https://rabiroshan.github.io/snake_game/ 源码在此：https://github.com/RabiRoshan/snake_game 俄罗斯方块《俄罗斯方块》（Tetris）是一款由俄罗斯人阿列克谢·帕基特诺夫于1984年6月发明的休闲游戏。 游戏框架使用的是 React + Redux，其中再加入了 Immutable，以及一些 ES6 的语法。 玩一玩：https://chvin.github.io/react-tetris/源码：https://github.com/chvin/react-tetris 2048 2048是前几年流行的一款益智类单机游戏， 游戏的规则十分简单，合并消除，看你能活多久。 玩一玩：https://play2048.co/源码：https://github.com/gabrielecirulli/2048 今天介绍都的二维小游戏，如果你感兴趣，可以自己尝试着开发一个，这样你会发现，原来编程是这么有趣的一件事情。喜欢请点个赞。后期会给大家介绍3d游戏开发，敬请期待。 公号同步更新，欢迎关注 👻","link":"/717f27dc65d0/"},{"title":"好玩有趣的HTML标签","text":"我发现很多前端开发工程师会自己基于成熟的 ui 库开封装一些组件，而不是使用原始的 HTML。希望本文能为你的项目带来些新思路。 下面列举些 9 个有趣的 HTML 标签和属性，也希望你来补充些，请留言告诉我。 1. Progress bar 进度条1&lt;progress value=\"32\" max=\"100\"&gt;32%&lt;/progress&gt; 2. Expansion panel (折叠面板)1234567&lt;details&gt; &lt;summary&gt;Global Goals&lt;/summary&gt; &lt;p&gt; The Global Goals are a set of 17 commitments made by 193 world leaders, to end extreme poverty, inequality, and climate change by 2030.. &lt;/p&gt;&lt;/details&gt; 3. Dialog 对话框为网站添加对话框的语义方法。但在我看来，原生的 HTML 元素要逊色于用户界面库中的现成组件 12345&lt;dialog open&gt; &lt;p&gt;Greetings, one and all!&lt;/p&gt; &lt;button&gt;Close&lt;/button&gt;&lt;/dialog&gt; 4. Color selection 颜色选择器1&lt;input type=\"color\"&gt; 5. Base url HTML 标签指定文档中所有 URL 的基础 URL 1234&lt;base href=\"https://leonid-shvab.web.app/\"&gt;&lt;a href=\"contacts\"&gt;contacts&lt;/a&gt;&lt;a href=\"blog/000\"&gt;blog&lt;/a&gt; 6. Lazy loading 懒加载懒加载的本地实现。只需添加 loading=”lazy” 属性，就能在网络中逐一加载图片。该功能与浏览器的兼容性较弱。但就未来而言，它是懒加载的一个很好的解决方案 123&lt;img loading=\"lazy\" src=\"1.jpg\" height=\"400px\" width=\"400px\"&gt;&lt;img loading=\"lazy\" src=\"2.jpg\" height=\"400px\" width=\"400px\"&gt;&lt;img loading=\"lazy\" src=\"3.jpg\" height=\"400px\" width=\"400px\"&gt; 7. Calendar 日历原生日历见过吗？ 1&lt;input type=\"date\"&gt; 8. Single range 数字区间1&lt;input type=\"range\" min=\"0\" max=\"50\"&gt; 9. Content editable一个有趣的属性，可以编辑文本块 123&lt;p contenteditable=\"true\"&gt; You can edit this block of text.&lt;/p&gt; 原文链接：https://medium.com/@leonidshvab1996/interesting-html-tags-89ecc04cb2a9 公号同步更新，欢迎关注 👻","link":"/91c73277218b/"},{"title":"我的 Obsidian 笔记跨设备同步方案","text":"前言 在写这篇文章之前，我用过有道云笔记，简单的设计，后来写的东西越来越多，在一次深夜软件卡顿丢失了文档，反复纠结还是放弃了它，转向了印象笔记，印象强大很多，一直在用，用了很多年。 有图为证 身边很多同事也在用，可以做清单，打卡，思维导图，md，ocr, 周边工具也很好用，浏览器插件，比如【剪藏】，就可以把网页完整收藏在笔记里。 手机上看到不错的文章，就想收藏起来，直接发送链接至微信公众号也可以直接保存。这样在电脑上可以直接翻看，不会遗漏了。 但是现在，家里设备越来越多，手机，pad，家里电脑，公司电脑，印象笔记限制设备登录，提醒次数越来越多，头疼不已，加上window版本的印象笔记ui设计的实在难以忍受了。加上口罩影响，我觉得极致简单，数据安全是首选。 本着就要折腾的原则，我决定去找一款最适合我的笔记，然后我选择了Obsidian，简单没有广告。很快我就下手了 特点 纯净，无广告 编辑Markdown非常舒服 双链和Tag来关联内容，知识点到片 丰富插件，可自行定制化，适合爱倒腾的程序员 数据存储安全，后续迁移至其他软件便捷 个人免费，但是同步数据价格却。。。 同步方案先购入阿里OSShttps://common-buy.aliyun.com/?commodityCode=ossbag&amp;spm=5176.28061389.commonbuy2container.oss_rc_dp_cn_ZjqTabLinks_2.205b778bdeaezx，费用40G，5年45RMB，遇上优惠活动还有更低的折扣，很划算啦啦当然你也可以选择腾讯云 COS。 进入OSS管理控制台 ，选择[创建Bucket]，填写Bucket名称 和 地域（地域选择离自己最近的地方）即可 跨域设置 - 选择创建规则， 并在 来源 填入如下信息 123app://obsidian.mdcapacitor://localhosthttp://localhost 授权设置 - 右上角个人头像，AccessKey管理 使用子用户 AccessKey，创建一个用户 成功护，复制下AccessKey ID 和 AccessKey Secret，页面关闭就无法再次获取了 给新建的用户授权 - 权限管理 -&gt; Bucket授权策略 然后点击“新增授权”，在弹出页面选定子账号，授权操作选了“读/写”，”完全控制“ Obsidian 安装官网点击下载：https://obsidian.md/, 安装 Obsidian 插件 设置-选项-第三方插件-社区插件市场 点击浏览 输入搜索：Remotely Save 安装插件 启用插件 配置参数 服务地址 对应 外网访问 区域 对应 ECS 的经典网络访问（内网） AccessKeyID 和 SecretAccessKey 对应刚刚让你复制的2个key BucketName 对应 阿里云OSS 内的bucket名字 回到笔记，点击侧边栏的 Remotely Save 或在命令面板执行 Remotely Save: start sync，即可开始第一次同步 看到这个就同步成功了，前往oss看看，出现了你的笔记就OK了。 至此就完成了。 推荐插件如果你也喜欢用微信读书，一定要试试 obsidian-weread-plugin 这个插件。 登录之后它可以帮你同步你在微信读书上做的笔记。","link":"/0b3df051877a/"},{"title":"我最近在用的5个好东西","text":"原文：https://medium.com/geekculture/the-5-paid-subscriptions-i-actually-use-in-2023-as-a-software-engineer-9418515a315a作者：Jacob Bennett 以下是我在2022-23年花钱购买的、真正改善了我作为一个软件工程师工作效率的东西 1. GitHub Copilot: AI编程助手 当我在写代码时，Copilot在后台工作，阅读我写的东西，并悄悄地建议我接下来可能要写的东西 编写测试用例。大多数时候，我会为测试用例写下名称，而 Copilot 会填写其他所有内容。 功能函数。例如我没有写了一条评论来解释我希望 RegEx 做什么 ps: 在VSCode的插件菜单中搜索 Copilot，即可找到这个插件。 2. Kagi: 一个比谷歌更好的搜索引擎我用找到我真正要找的东西所花的时间来衡量搜索的有效性。按照这个标准，谷歌一直在稳步恶化。当我在 Kagi 上搜索内容时，95% 的情况下，正确的结果出现在前 2 个链接中。它在 99% 的时间内位于前 5 个链接中。 Google、Bing 等不会发生这种情况。搜索结果页面的持续出色是由我控制的搜索个性化进一步提升的。比如告诉Kagi，任何来自Stack Overflow或Medium的结果都应该被赋予更高的权重，并阻止了其他我不想看到结果的网站。 3. Midjourney: AI生成图片 Midjourney与Discord整合，将AI图像的生成直接带到聊天中。我花了3分钟创建了下面的游戏广场，在几个结果上反复斟酌，最后选择了一个（我从未改变过我的prompt[prompt: “isometric diaroma of a forest kingdom, large game map, clean SVG vector”]）。 当我在Medium上写技术文章时，我确实需要很多图片。我喜欢用Midjourney制作自己的图片，而不是用Unsplash图片来制作文章。 4. Scribd：一个巨大的电子书和有声读物图书馆。Scribd是一个付费图书馆，里面有流行的电子书、有声读物、杂志等等。他们的图书馆不断更新，而且所有内容都是一次性订阅的（与Audible相比，你要按书名付费）。我在旅行时听有声读物，我经常在家里的闲暇时间（越来越少）阅读电子书。多年来，Scribd一直是我稳定的订阅对象，我从中获得了巨大的成长。 5. Medium: 国外优质博客网站我最喜欢的向其他领域的人学习的平台是这个博客平台（Medium）。在这里，你可以阅读数以千计的关于编程、数据科学、技术等方面的优质文章。 多年来我一直是Medium的粉丝，我终于有机会从2022年开始为他们工作（是的，完全公开，我在这里工作…但我真的很喜欢这个平台！）。 6. Excalidraw写作时，大多数图表我都是用Excalidraw创建的，这使得它们变得干净、有趣和可编辑。 我非常关心把钱花在改善工作效率的事情上。作为一名软件工程师，这些工具为我带来了巨大的价值。希望你也能收益。","link":"/6cee586f56d9/"},{"title":"如何制作数据可视化大屏的城市地图","text":"最近接到一个新需求，在大屏上展示一个地图，这篇文章来记录下。 图片来自 https://igaowei.github.io/BigDataView/ Echart 结合百度地图地图下钻到区县还是容易做的，最好是百度地图，后期不用自己更新地图数据 json 了，但是样式是整个中国地图样式，看起来东西太多。 可以看到官方提供的案例, 前往https://lbsyun.baidu.com/solutions/mapvdata查看更多。 https://mapv.baidu.com/gl/examples/editor.html#circle.html 首先到百度地图https://lbs.baidu.com/index.php?title=jspopularGL/guide/getkey申请一个ak key,然后在代码中加载百度地图 api echart 提供了 demo: https://echarts.apache.org/examples/zh/editor.html?c=effectScatter-bmap Echart 来开发某区的地图DataV.GeoAtlas 地理小工具系列，通过网站，能得到【省、市、县、区】的地理坐标数据。非常方便 https://datav.aliyun.com/portal/school/atlas/area_selector 点击点击寻找到你的地区，然后粘贴到你的地理坐标数据 json 1234let cqMapChart = echarts.init(document.getElementById(\"map\"));echarts.registerMap(this.mapName, require(`[json路径]`));cqMapChart.resize();cqMapChart.setOption(option, true); 可以做到这样的效果，按色块来展示每一个地图 Echart 来开发街道、乡镇的地图使用制图软件 bigemap, 我们只需要用到免费功能就能做，过程有点复杂 下载软件 bigemap http://www.bigemap.com/ 导出该区所有街道的 bmv 格式数据 直接将 bmv 格式文件拖入视图 右击下载地图 这里的 kml 文件就是我们最终需要的。 一次只能一个任务，记得在这里点取消 汇集地图 数据合并 我们前往https://geojson.io/#new&amp;map=7.18/33.498/119.9，把所有的 kml 文件直接拖进左侧，然后右侧就会生成我们需要的数据 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101let option = { layoutCenter: [\"50%\", \"50%\"], //位置 layoutSize: \"86%\", tooltip: { show: true, trigger: \"item\", backgroundColor: \"rgba(0, 21, 77, 0.74);\", //浮框背景 borderColor: \"#7FE2F5\", textStyle: { color: \"white\", }, borderWidth: 1, padding: 5, }, geo: { show: true, map: this.mapName, label: { normal: { color: \"white\", fontSize: 10, show: true, //显示省份名称 }, }, tooltip: { trigger: \"item\", }, roam: false, zoom: 1.0, itemStyle: { normal: { show: true, areaColor: \"rgba(43, 196, 243, 0.7)\", borderColor: \"rgba(43, 196, 243, 1)\", borderWidth: 1, shadowBlur: 20, shadowColor: \"rgba(0, 0, 0, 0.5)\", }, emphasis: { show: true, areaColor: \"#24cbff\", shadowBlur: 20, shadowColor: \"rgba(0, 0, 0, 0.5)\", }, }, }, geo: { regions: [ { itemStyle: { normal: { areaColor: colors, // 颜色 borderColor: \"rgba(43, 196, 243, 1)\", }, }, }, ], }, series: [ { name: \"服务中\", type: \"effectScatter\", coordinateSystem: \"geo\", symbolSize: 6, data: [], itemStyle: { normal: { show: true, color: \"#00fea6\", shadowBlur: 100, shadowColor: \"#fff\", }, }, rippleEffect: { brushType: \"stroke\", }, }, { name: \"已服务\", type: \"scatter\", coordinateSystem: \"geo\", symbolSize: 6, animation: false, data: [], itemStyle: { normal: { show: true, color: \"#fafa01\", shadowBlur: 100, shadowColor: \"#fff\", }, }, data: [], }, ],};cqMapChart = echarts.init(this.$refs.map, null, { renderer: \"svg\",});echarts.registerMap(this.mapName, mapJson);cqMapChart.setOption(option, true); 最终效果 附上链接 https://datav.aliyun.com/portal/school/atlas/area_selector http://www.bigemap.com/ https://geojson.io/#new&amp;map=7.18/33.498/119.9","link":"/b94651a21a4c/"},{"title":"用NodeJs来实现爬虫Medium会员文章","text":"背景：大名鼎鼎的Medium平台, 首先需要注册，使用邮箱注册用户，分为免费用户和付费会员，免费用户每个月可以免费查看三篇文章，会员可以查看所有的优质文章，费用 5 Dollar / Month 或者 50 Dollar / Year。 关于爬虫，之前写过一篇比较入门的文章 (传送门：https://www.noraxu.online/f0142a5f6230/) 今天接着介绍 分析页面 这里是我们目标页面，按下F12, 或者右击【检查】, 看到它的html页面结构如下图，h2标签是文章标题 抓取列表页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 页面抓取const chromium = require('chrome-aws-lambda');async pageOne(tag) { const { app } = this; // 浏览器 const main = await chromium.puppeteer.launch(app.config.puppeteer.config); browser = await main.createIncognitoBrowserContext(); // 打开标签页tab const page = await browser.newPage(); await page.setUserAgent(app.config.puppeteer.agent); // 拦截不要的文件加载，速度更快 await page.setRequestInterception(true); page.on('request', req =&gt; { if ([ 'image', 'stylesheet', 'font' ].includes(req.resourceType())) { return req.abort(); } return req.continue(); }); // goto我们目标页面 await page.goto(`https://medium.com/tag/javascript`, { waitUntil: 'domcontentloaded', }); // 等待我们页面加载完成 await page.waitForSelector('article'); // 生成图片 // await page.screenshot({ // path: 'images/' + tag + '.png', // fullPage: true, // }); // 遍历页面 const hotels = await page.$$eval('article', anchors =&gt; { return anchors.map(anchor =&gt; { const item = anchor.querySelector(\"a[aria-label='Post Preview Title']\"); const img = anchor.querySelector('img'); const author = anchor.querySelector(\"div[style='flex: 1 1 0%;']\") || anchor.querySelector(\"div[style='flex:1']\"); const one = { href: (item.href), // 文章链接 title: item.querySelector('h2').innerText, // 标题 content: item.querySelector('p').innerText, // 文章缩略图 thumb: img.src, // 作者头像 author: (author.querySelector('a').href), // 作者主页地址 authorName: author.querySelector('p').innerText, // 作者名称 }; return one; }); }); await page.close(); return hotels;} 1234567891011121314151617181920212223242526272829// config.default.js文件配置config: { // headless: false, // product: 'firefox', // executablePath: 'C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe', // executablePath: 'C:/Program Files/Google/Chrome/Application/chrome.exe', ignoreHTTPSErrors: true, devtools: false, args: [ '--disable-blink-features=AutomationControlled', // '--blink-settings=imagesEnabled=false', // '--proxy-server=\"direct://\"', // '--proxy-bypass-list=*', '–no-first-run', '–no-zygote', '–single-process', '--no-sandbox', // 沙盒模式 '--disable-setuid-sandbox', // uid沙盒 '--disable-dev-shm-usage', // 创建临时文件共享内存 '--disable-accelerated-2d-canvas', // canvas渲染 '--disable-gpu', // GPU硬件加速 ], dumpio: false, // defaultViewport: { // width: 1024, // height: 1024, // deviceScaleFactor: 1, // },}, 抓取结果打印出来 抓取会员详情页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354async detailOne(site) {、 const browser = await puppeteer.launch({ headless: true, args: ['--proxy-server=PROXY_SERVER_ADDRESS'] }); const page = await browser.newPage(); // 有些网站也会根据浏览器发送到请求头判断访问者是真实用户还是爬虫， // 这时候我们就可以通过设置 User-Agent 来防止被网站限制访问 // 实现: 随机生成agent const userAgent = 'Mozilla/5.0(WindowsNT10.0;Win64;x64)AppleWebKit/537.36(KHTML,likeGecko)Chrome/' + 59 + Math.round(Math.random() * 10) + '.0.3497.' + Math.round(Math.random() * 100) + 'Safari/537.36'; await page.setUserAgent(userAgent); //拦截图片，样式，脚本，字体加载，速度快很多 await page.setRequestInterception(true); page.on('request', req =&gt; { if ( [ 'javascript', 'image', 'stylesheet', 'font' ].includes( req.resourceType() ) ) { return req.abort(); } return req.continue(); }); // 设置动态代理 await page.authenticate({ username: 'xxxx', password: 'xxxx', }); await page.goto(site, { waitUntil: 'domcontentloaded', }); await page.waitForSelector('article'); const detail = await page.$eval('article', el =&gt; el.innerHTML); console.log('detail: ', detail); await page.close(); return { detail, };} 数据库mysql保存数据库挂载 123456789 // {app_root}/app.jsmodule.exports = app =&gt; { app.beforeStart(async () =&gt; { // 从配置中心获取 MySQL 的配置 const mysqlConfig = await app.configCenter.fetch('mysql'); app.database = app.mysql.createInstance(mysqlConfig); });}; 保存数据 12345678910await app.mysql.insert('medium', { uid: item.uid, href: item.href, title: item.title, content: item.content, thumb: item.thumb, author: item.author, authorName: item.authorName, detail: item.detail,}) 定时任务来自动执行123456789101112// schedule/publish.jsmodule.exports = { schedule: { immediate: true, interval: '1h', type: 'all', }, async task(ctx) { await ctx.service.medium.getAllPost(); },}; 成果如果感兴趣请看我的成品：https://next-blog-three-hazel.vercel.app/post/javascript?page=1 内容自己学习，请勿传播。","link":"/c53c25628429/"},{"title":"如何优化你的博客SEO来获取流量","text":"在如今火爆的短视频时代，我依旧相信文字的力量。直接有效，传达文字的力量直击人心。很多技术人都拥有自己的博客，或记录，或贴广告赚银子，都需要足够的流量。省流：在本文中，我们将讨论一些基于 next.js 关键的 seo 技术实操，帮助你优化网站的 SEO，从而吸引更多的读者，并扩大网站的影响力和公众力。 什么是 NEXT.JS这里不多说了，你可以翻看这篇 地址 什么是 SEOSEO 是搜索引擎优化的缩写。它是提高网站在谷歌、必应和百度等搜索引擎中的可见度的过程。搜索引擎优化有助于提高网站在搜索结果中的排名，为网站带来更多流量。 搜索引擎优化是一个复杂的过程，需要花费大量的时间和精力。这不是一朝一夕就能完成的事情，但如果你想为自己的网站带来更多流量，付出努力是值得的。 Next.js 具有一些内置功能，可以让您更轻松地构建搜索引擎友好型网站。 实践Robots.txt我们首先要做的是在网站根目录下创建 robots.txt 文件。该文件会告诉搜索引擎哪些页面需要抓取，哪些页面不需要抓取。 您可以使用以下代码创建 robots.txt 文件： 123456789101112131415// app/robots.ts (App Router)import { MetadataRoute } from \"next\";const robots: MetadataRoute.Robots = () =&gt; { return { rules: { userAgent: \"*\", allow: \"/\", disallow: \"/private/\", }, sitemap: \"https://example.com/sitemap.xml\", };};export default robots; Sitemap.xml接下来要做的是在网站根目录下创建一个 sitemap.xml 文件。该文件会告诉搜索引擎哪些页面需要抓取，哪些页面不需要抓取。 Next.js 可以为你生成 sitemap.xml 文件。您可以使用以下代码生成 sitemap.xml 文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// app/sitemap.ts (App Router)import { allPosts } from \"/example.ts\";import { MetadataRoute } from \"next\";export default async function sitemap(): Promise&lt;MetadataRoute.Sitemap&gt; { const blogs = allPosts; const URL = \"https://example.com\"; const restUrls = [ { url: `${URL}/`, // 首页 lastModified: new Date(), priority: 1.0, changeFrequency: \"weekly\", }, { url: `${URL}/blogs`, lastModified: new Date(), priority: 0.8, changeFrequency: \"daily\", }, { url: `${URL}/projects`, lastModified: new Date(), priority: 0.8, changeFrequency: \"weekly\", }, { url: `${URL}/skills`, lastModified: new Date(), priority: 0.8, changeFrequency: \"weekly\", }, ]; const allBlogs = blogs.map(({ slugAsParams, date }) =&gt; { return { url: `${URL}/blog/${slugAsParams}`, lastModified: new Date(date), priority: 0.64, changeFrequency: \"daily\", }; }); return [...restUrls, ...allBlogs];} 我们可以使用 generateSitemaps 为每篇博文生成动态路由。 1234567891011// app/sitemap.ts (App Router)export async function generateSitemaps() { return [{ id: \"one\" }, { id: \"two\" }, { id: \"three\" }, { id: \"four\" }];}export default async function sitemap({ id,}: { id: string,}): Promise&lt;MetadataRoute.Sitemap&gt; {} 元标签优化元标签是提供网站元数据的 HTML 标签。搜索引擎使用它们来确定网站的内容以及在搜索结果中的排名。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// app/layout.tsx (App Router)// app/page.tsx (App Router)import { Metadata } from \"next\";export async function generateMetadata(): Promise&lt;Metadata&gt; { return { metadataBase: new URL(\"https://example.com\"), title:\"Name, description: \"description\", authors: [ { name: \"Site Name\", url: \"https://example.com\", }, ], twitter: { card: \"summary_large_image\", creator: \"@example\", images: \"some-image\", }, robots: \"index, follow\", alternates: { canonical: `https://example.com`, languages: { \"en-US\": \"/\", }, }, openGraph: { type: \"website\", url: `https://example.com`, title: \"name\", description: \"description\", siteName: \"Site Name\", images: [ { url: \"some-image\", }, ], }, assets: \"some-image\", keywords: [ \"keywords\" ], };} 我们可以在 app/layout.tsx 或 app/page.tsx 文件中使用 generateMetadata 函数。 如果希望每个页面都有单独的元标记，可以在不同页面中使用相同的 generateMetadata 函数。您可以提取出 utils 方法，然后在您的 app/layout.tsx 或 app/page.tsx 文件中调用该函数。 123456789101112131415// app/layout.tsx (App Router)// app/page.tsx (App Router)export async function generateMetadata() { const metaData = commonMetaData({ name: \"\", desc: \"\", image: \"https:example.com/images/hero.png\", url: \"/\", keywords: [], }); return { ...metaData, };} 优化图片和字体Next.js 内置了图像组件，用于优化图像。我强烈建议使用图像组件而不是 img 标签。 Next.js next/font 为我们提供了优化字体的方法。它将自动优化字体（包括自定义字体）并移除外部网络请求，从而提高隐私保护和性能。 123456789101112131415161718192021// app/layout.tsx (App Router)import { Roboto } from \"next/font/google\";const roboto = Roboto({ weight: \"400\", subsets: [\"latin\"], display: \"swap\",});export default function RootLayout({ children,}: { children: React.ReactNode,}) { return ( &lt;html lang=\"en\" className={roboto.className}&gt; &lt;body&gt;{children}&lt;/body&gt; &lt;/html&gt; );} 图片和字体对搜索引擎优化非常重要。它们可以帮助搜索引擎了解网站的内容以及在搜索结果中的排名。 它还有助于通过减少网络请求的数量来提高网站的性能。 优化第三方脚本第三方脚本会在使用它的路由被访问时被提取。这意味着只有在需要时才会获取脚本，从而减少了网络请求的数量并提高了性能。 1234567891011121314// app/layout.tsx (App Router)import Script from \"next/script\";const RootLayout = ({ children }: { children: React.ReactNode }) =&gt; { return ( &lt;&gt; {children} &lt;Script src=\"https://example.com/script.js\" /&gt; &lt;/&gt; );};export default RootLayout; 结论Next.js 是一个用于构建搜索引擎友好型网站的出色框架。内置的功能就能让搜索引擎优化友好型网站的构建变得更容易。 https://medium.com/@rajreetesh7/best-seo-practices-for-next-js-apps-6cad24c0fb0e 公号同步更新，欢迎关注 👻","link":"/00f512f64112/"},{"title":"如何开发一个谷歌浏览器插件工具","text":"Chrome 是前端开发者日常使用的浏览器：拥有出色的性能、实用的开发工具和丰富的扩展。我相信你也安装过很多优秀的插件，比如 adblock,Google 文档等，也有许多优秀的前端开发者参与开发插件，并带来了可观的收入。在本文中，我将基于 TypeScript 模板一步一步创建 Chrome 扩展程序，告诉你 chrome 插件开发和普通网页开发有什么区别 创建 React 应用程序首先，我们需要创建一个新的 TypeScript React 项目。打开终端或命令提示符并运行以下命令 12npx create-react-app react-chrome-ext --template typescriptcd react-chrome-ext 让我们删除目前不需要的文件。确保删除后您的文件夹结构如下所示： App.tsx12345function App() { return &lt;div className=\"App\"&gt;Hello World&lt;/div&gt;;}export default App; index.tsx12345678910111213import React from \"react\";import ReactDOM from \"react-dom/client\";import App from \"./App\";const root = document.createElement(\"div\");root.className = \"container\";document.body.appendChild(root);const rootDiv = ReactDOM.createRoot(root);rootDiv.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;); App.css12345678910.App { color: white; text-align: center;}.container { width: 15rem; height: 15rem; background-color: green;} Webpack接下来，我们需要安装必要的依赖项 1npm install --save-dev webpack webpack-cli copy-webpack-plugin css-loader html-webpack-plugin ts-node 创建 webpack.config.js 文件，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const path = require(\"path\");const HTMLPlugin = require(\"html-webpack-plugin\");const CopyPlugin = require(\"copy-webpack-plugin\");module.exports = { entry: { index: \"./src/index.tsx\", }, mode: \"production\", module: { rules: [ { test: /\\.tsx?$/, use: [ { loader: \"ts-loader\", options: { compilerOptions: { noEmit: false }, }, }, ], exclude: /node_modules/, }, { exclude: /node_modules/, test: /\\.css$/i, use: [\"style-loader\", \"css-loader\"], }, ], }, plugins: [ new CopyPlugin({ patterns: [{ from: \"manifest.json\", to: \"../manifest.json\" }], }), ...getHtmlPlugins([\"index\"]), ], resolve: { extensions: [\".tsx\", \".ts\", \".js\"], }, output: { path: path.join(__dirname, \"dist/js\"), filename: \"[name].js\", },};function getHtmlPlugins(chunks) { return chunks.map( (chunk) =&gt; new HTMLPlugin({ title: \"React extension\", filename: `${chunk}.html`, chunks: [chunk], }) );} 现在我们已经配置了 webpack，更新您的 package.json 文件,代码如下： 1234\"scripts\" : { \"build\" : \"webpack --config webpack.config.js\" , \"watch\" : \"webpack -w --config webpack.config.js\" } 这脚本将允许使用命令构建扩展 npm run build，或者使用命令在监视模式下运行 Webpack：npm run watch manifest.json用于定义 Chrome 扩展程序的元数据和权限。在项目的根目录中创建一个名为的新文件 manifest.json 并添加以下代码： 12345678910{ \"version\": \"1.0.0\", \"manifest_version\": 3, \"name\": \"React Chrome 扩展\", \"description\": \"这是一个使用 React 和 TypeScript 构建的 Chrome 扩展\", \"action\": { \"default_popup\": \"js/index.html\", \"default_title\": \"React Chrome 扩展\" }} 指定扩展的名称、版本和描述。它还定义了弹出窗口 构建应用程序最后，在终端中运行 npm run build/dist 命令来构建扩展：当脚本完成时 → 将在我们应用程序的根目录中创建新文件夹： 加载扩展要将扩展程序加载到 Chrome 中，打开 Chrome 并通过 chrome://extensions 在地址栏中键入内容导航到“扩展程序”页面。然后，单击“加载解压”按钮并选择 dist 项目中的目录。通过重新加载扩展页面并单击扩展图标来测试扩展。 结论就是这样！您已经使用 TypeScript 和 Webpack 创建了一个简单的“Hello World”Chrome 扩展 https://medium.com/@tharshita13/creating-a-chrome-extension-with-react-a-step-by-step-guide-47fe9bab24a1 公号同步更新，欢迎关注 👻","link":"/077811e5a74e/"}],"tags":[{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"webapck","slug":"webapck","link":"/tags/webapck/"},{"name":"Puppeteer","slug":"Puppeteer","link":"/tags/Puppeteer/"},{"name":"UI自动化测试工具","slug":"UI自动化测试工具","link":"/tags/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"uniapp","slug":"uniapp","link":"/tags/uniapp/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"app","slug":"app","link":"/tags/app/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"vue-cli","slug":"vue-cli","link":"/tags/vue-cli/"},{"name":"读书","slug":"读书","link":"/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"DevOps","slug":"DevOps","link":"/tags/DevOps/"},{"name":"运维","slug":"运维","link":"/tags/%E8%BF%90%E7%BB%B4/"},{"name":"Jenkins","slug":"Jenkins","link":"/tags/Jenkins/"},{"name":"前端工程化","slug":"前端工程化","link":"/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"NodeJs","slug":"NodeJs","link":"/tags/NodeJs/"},{"name":"微信开发","slug":"微信开发","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"},{"name":"eggJs","slug":"eggJs","link":"/tags/eggJs/"},{"name":"管理","slug":"管理","link":"/tags/%E7%AE%A1%E7%90%86/"},{"name":"技术团队","slug":"技术团队","link":"/tags/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F/"},{"name":"领导力","slug":"领导力","link":"/tags/%E9%A2%86%E5%AF%BC%E5%8A%9B/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"小程序开发","slug":"小程序开发","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"副业","slug":"副业","link":"/tags/%E5%89%AF%E4%B8%9A/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"babel","slug":"babel","link":"/tags/babel/"},{"name":"前端优化","slug":"前端优化","link":"/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"},{"name":"ChatGPT","slug":"ChatGPT","link":"/tags/ChatGPT/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"低代码","slug":"低代码","link":"/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"UX","slug":"UX","link":"/tags/UX/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"eggjs","slug":"eggjs","link":"/tags/eggjs/"},{"name":"vercel","slug":"vercel","link":"/tags/vercel/"},{"name":"nextjs","slug":"nextjs","link":"/tags/nextjs/"}],"categories":[{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"工具, 自动化测试","slug":"工具-自动化测试","link":"/categories/%E5%B7%A5%E5%85%B7-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"uniapp","slug":"uniapp","link":"/categories/uniapp/"},{"name":"software","slug":"software","link":"/categories/software/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"book","slug":"book","link":"/categories/book/"},{"name":"前端工程化","slug":"前端工程化","link":"/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"翻译","slug":"翻译","link":"/categories/%E7%BF%BB%E8%AF%91/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"微信开发","slug":"微信开发","link":"/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"},{"name":"技术管理","slug":"技术管理","link":"/categories/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"flutter","slug":"flutter","link":"/categories/flutter/"},{"name":"副业","slug":"副业","link":"/categories/%E5%89%AF%E4%B8%9A/"},{"name":"eggJs","slug":"eggJs","link":"/categories/eggJs/"},{"name":"npm","slug":"npm","link":"/categories/npm/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"ChatGPT, AI, Javascript","slug":"ChatGPT-AI-Javascript","link":"/categories/ChatGPT-AI-Javascript/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"低代码","slug":"低代码","link":"/categories/%E4%BD%8E%E4%BB%A3%E7%A0%81/"},{"name":"UI","slug":"UI","link":"/categories/UI/"},{"name":"UX","slug":"UX","link":"/categories/UX/"},{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"eggjs","slug":"eggjs","link":"/categories/eggjs/"},{"name":"GitHub","slug":"GitHub","link":"/categories/GitHub/"},{"name":"Copilot","slug":"Copilot","link":"/categories/Copilot/"},{"name":"NodeJs","slug":"NodeJs","link":"/categories/NodeJs/"},{"name":"nextjs","slug":"nextjs","link":"/categories/nextjs/"},{"name":"Puppeteer","slug":"Puppeteer","link":"/categories/Puppeteer/"},{"name":"vercel","slug":"vercel","link":"/categories/vercel/"}]}